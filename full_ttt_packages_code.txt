
================================================================================
FILE PATH: package.json
================================================================================
{
    "name": "ttt-packages",
    "version": "1.0.1",
    "private": true,
    "description": "Shared packages for TTT Productions and Q-Sports",
    "workspaces": [
        "packages/*"
    ],
    "scripts": {
        "build": "npm run build -w @ttt-productions/ui-core && npm run build --workspaces --if-present",
        "clean": "npm run clean --workspaces --if-present",
        "test": "npm run test --workspaces --if-present",
        "lint": "npm run lint --workspaces --if-present",
        "typecheck": "npm run typecheck --workspaces --if-present"
    },
    "keywords": [
        "ttt",
        "packages",
        "shared",
        "react",
        "nextjs"
    ],
    "author": "DJ (TTT Productions)",
    "license": "MIT",
    "engines": {
        "node": ">=22",
        "npm": ">=10"
    },
    "devDependencies": {
        "@types/node": "^22.0.0",
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "typescript": "^5.8.3"
    },
    "dependencies": {
        "@tanstack/react-query": "^5.90.17",
        "firebase": "^10.14.1"
    }
}

================================================================================
FILE PATH: tsconfig.json
================================================================================
{
    "compilerOptions": {
      "target": "ES2022",
      "lib": ["ES2022", "DOM", "DOM.Iterable"],
      "module": "ESNext",
      "moduleResolution": "bundler",
      "jsx": "react-jsx",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "declaration": true,
      "declarationMap": true,
      "sourceMap": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true,
      "noEmit": false
    },
    "exclude": ["node_modules", "dist", "build"]
  }

================================================================================
FILE PATH: packages/auth-core/package.json
================================================================================
{
    "name": "@ttt-productions/auth-core",
    "version": "0.2.3",
    "description": "Shared Firebase authentication utilities and React hooks for TTT Productions apps",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/auth-core"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        },
        "./react": {
            "types": "./dist/react/index.d.ts",
            "default": "./dist/react/index.js"
        }
    },
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
        "firebase": ">=10.0.0",
        "react": ">=19.0.0",
        "react-dom": ">=19.0.0"
    },
    "peerDependenciesMeta": {
        "react": {
            "optional": true
        },
        "react-dom": {
            "optional": true
        }
    },
    "devDependencies": {
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "firebase": "^10.0.0",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/auth-core/src/auth.ts
================================================================================
import type { Auth, User } from "firebase/auth";
import { onAuthStateChanged as fbOnAuthStateChanged } from "firebase/auth";

export type Unsubscribe = () => void;

export function getAuthUser(auth: Auth): User | null {
  return auth.currentUser;
}

/**
 * Thin wrapper around Firebase onAuthStateChanged.
 * - always returns the unsubscribe function
 * - preserves Firebase callback signature
 */
export function onAuthStateChanged(
  auth: Auth,
  cb: (user: User | null) => void,
  onError?: (error: unknown) => void
): Unsubscribe {
  return fbOnAuthStateChanged(auth, cb, onError);
}


================================================================================
FILE PATH: packages/auth-core/src/claims.ts
================================================================================
import type { Auth, User, IdTokenResult } from "firebase/auth";

export type IdTokenClaims = IdTokenResult["claims"];

export type ParsedClaims = {
  // common defaults (kept generic)
  roles: string[];
  // raw claims for app-level decisions
  raw: IdTokenClaims;
};

/**
 * Get the current user's ID token claims.
 * Returns null if no current user.
 */
export async function getIdTokenClaims(user: User | null): Promise<IdTokenClaims | null> {
  if (!user) return null;
  const res = await user.getIdTokenResult(false);
  return res.claims;
}

/**
 * Forces refresh of ID token + claims.
 * Returns null if no current user.
 */
export async function refreshClaims(user: User | null): Promise<IdTokenClaims | null> {
  if (!user) return null;
  const res = await user.getIdTokenResult(true);
  return res.claims;
}

/**
 * Convenience helper when you only have Auth.
 */
export async function refreshClaimsFromAuth(auth: Auth): Promise<IdTokenClaims | null> {
  return refreshClaims(auth.currentUser);
}

/**
 * Keep parsing intentionally minimal and generic:
 * - normalize "roles" into string[]
 * - keep raw claims attached
 */
export function parseClaims(claims: IdTokenClaims | null | undefined): ParsedClaims {
  const raw = (claims ?? {}) as IdTokenClaims;

  const rolesValue = (raw as any).roles;
  const roles =
    Array.isArray(rolesValue) ? rolesValue.filter((x) => typeof x === "string") :
    typeof rolesValue === "string" ? [rolesValue] :
    [];

  return { roles, raw };
}


================================================================================
FILE PATH: packages/auth-core/src/errors.ts
================================================================================
export type AuthErrorCode =
  | "AUTH_UNKNOWN"
  | "AUTH_NETWORK_ERROR"
  | "AUTH_TOO_MANY_REQUESTS"
  | "AUTH_POPUP_CLOSED"
  | "AUTH_POPUP_BLOCKED"
  | "AUTH_CANCELLED"
  | "AUTH_USER_DISABLED"
  | "AUTH_USER_NOT_FOUND"
  | "AUTH_WRONG_PASSWORD"
  | "AUTH_INVALID_EMAIL"
  | "AUTH_EMAIL_ALREADY_IN_USE"
  | "AUTH_WEAK_PASSWORD"
  | "AUTH_REQUIRES_RECENT_LOGIN"
  | "AUTH_INVALID_CREDENTIAL"
  | "AUTH_ACCOUNT_EXISTS_WITH_DIFFERENT_CREDENTIAL"
  | "AUTH_PROVIDER_ALREADY_LINKED"
  | "AUTH_CREDENTIAL_ALREADY_IN_USE";

export type NormalizedAuthError = {
  code: AuthErrorCode;
  message: string;
  firebaseCode?: string;
  details?: Record<string, unknown>;
};

function pickFirebaseCode(err: unknown): string | undefined {
  if (!err || typeof err !== "object") return undefined;
  const anyErr = err as any;
  const c = anyErr.code;
  return typeof c === "string" ? c : undefined;
}

const MAP: Record<string, { code: AuthErrorCode; message: string }> = {
  "auth/network-request-failed": {
    code: "AUTH_NETWORK_ERROR",
    message: "Network error. Please check your connection and try again."
  },
  "auth/too-many-requests": {
    code: "AUTH_TOO_MANY_REQUESTS",
    message: "Too many attempts. Please wait a moment and try again."
  },
  "auth/popup-closed-by-user": {
    code: "AUTH_POPUP_CLOSED",
    message: "Sign-in popup was closed."
  },
  "auth/popup-blocked": {
    code: "AUTH_POPUP_BLOCKED",
    message: "Sign-in popup was blocked by the browser."
  },
  "auth/cancelled-popup-request": {
    code: "AUTH_CANCELLED",
    message: "Sign-in was cancelled."
  },
  "auth/user-disabled": {
    code: "AUTH_USER_DISABLED",
    message: "This account has been disabled."
  },
  "auth/user-not-found": {
    code: "AUTH_USER_NOT_FOUND",
    message: "No account found with that email."
  },
  "auth/wrong-password": {
    code: "AUTH_WRONG_PASSWORD",
    message: "Incorrect password."
  },
  "auth/invalid-email": {
    code: "AUTH_INVALID_EMAIL",
    message: "Invalid email address."
  },
  "auth/email-already-in-use": {
    code: "AUTH_EMAIL_ALREADY_IN_USE",
    message: "That email is already in use."
  },
  "auth/weak-password": {
    code: "AUTH_WEAK_PASSWORD",
    message: "Password is too weak."
  },
  "auth/requires-recent-login": {
    code: "AUTH_REQUIRES_RECENT_LOGIN",
    message: "Please re-authenticate and try again."
  },
  "auth/invalid-credential": {
    code: "AUTH_INVALID_CREDENTIAL",
    message: "Invalid credentials. Please try again."
  },
  "auth/account-exists-with-different-credential": {
    code: "AUTH_ACCOUNT_EXISTS_WITH_DIFFERENT_CREDENTIAL",
    message: "An account already exists with a different sign-in method."
  },
  "auth/provider-already-linked": {
    code: "AUTH_PROVIDER_ALREADY_LINKED",
    message: "That provider is already linked to this account."
  },
  "auth/credential-already-in-use": {
    code: "AUTH_CREDENTIAL_ALREADY_IN_USE",
    message: "Those credentials are already associated with another account."
  }
};

export function normalizeAuthError(err: unknown, details?: Record<string, unknown>): NormalizedAuthError {
  const firebaseCode = pickFirebaseCode(err);

  const mapped = firebaseCode ? MAP[firebaseCode] : undefined;
  if (mapped) {
    return {
      code: mapped.code,
      message: mapped.message,
      firebaseCode,
      details
    };
  }

  // best-effort message (don’t leak weird objects)
  const msg =
    typeof (err as any)?.message === "string"
      ? (err as any).message
      : "Authentication error. Please try again.";

  return {
    code: "AUTH_UNKNOWN",
    message: msg,
    firebaseCode,
    details
  };
}


================================================================================
FILE PATH: packages/auth-core/src/index.ts
================================================================================
export * from "./auth";
export * from "./claims";
export * from "./errors";


================================================================================
FILE PATH: packages/auth-core/src/react/index.ts
================================================================================
export * from "./useAuthState";


================================================================================
FILE PATH: packages/auth-core/src/react/useAuthState.ts
================================================================================
import { useEffect, useState } from "react";
import type { Auth, User } from "firebase/auth";
import { onAuthStateChanged } from "../auth";

export type AuthState = {
  user: User | null;
  loading: boolean;
  error: unknown | null;
};

export function useAuthState(auth: Auth): AuthState {
  const [user, setUser] = useState<User | null>(() => auth.currentUser);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<unknown | null>(null);

  useEffect(() => {
    setLoading(true);
    const unsub = onAuthStateChanged(
      auth,
      (u) => {
        setUser(u);
        setError(null);
        setLoading(false);
      },
      (e) => {
        setError(e);
        setLoading(false);
      }
    );
    return unsub;
  }, [auth]);

  return { user, loading, error };
}


================================================================================
FILE PATH: packages/auth-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}


================================================================================
FILE PATH: packages/chat-core/package.json
================================================================================
{
  "name": "@ttt-productions/chat-core",
  "version": "0.2.3",
  "description": "Shared Firestore chat core (realtime newest window + infinite older pagination) for TTT Productions apps",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ttt-productions/ttt-packages.git",
    "directory": "packages/chat-core"
  },
  "type": "module",
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "clean": "rm -rf dist *.tsbuildinfo",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "npm run clean && npm run build"
  },
  "peerDependencies": {
    "@tanstack/react-query": ">=5.0.0",
    "firebase": ">=10.0.0",
    "react": ">=19.0.0",
    "react-dom": ">=19.0.0"
  },
  "dependencies": {
    "@ttt-productions/ui-core": "^0.1.25"
  },
  "devDependencies": {
    "@types/react": "^19.0.0",
    "react": "^19.0.0",
    "typescript": "^5.8.3"
  },
  "author": "DJ (TTT Productions)",
  "license": "MIT"
}


================================================================================
FILE PATH: packages/chat-core/src/firestore/queries.ts
================================================================================
import type { Firestore, Query, DocumentData } from "firebase/firestore";
import { collection, query, orderBy, limit } from "firebase/firestore";

export function threadDocPath(chatCollection: string, threadId: string) {
  return [chatCollection, threadId] as const;
}

export function messagesColPath(chatCollection: string, threadId: string) {
  return [chatCollection, threadId, "messages"] as const;
}

export function newestWindowQuery(
  db: Firestore,
  chatCollection: string,
  threadId: string,
  createdAtField: string,
  pageSize: number
): Query<DocumentData> {
  return query(
    collection(db, ...messagesColPath(chatCollection, threadId)),
    orderBy(createdAtField, "desc"),
    limit(pageSize)
  );
}


================================================================================
FILE PATH: packages/chat-core/src/hooks/useChatMessages.ts
================================================================================
"use client";

import * as React from "react";
import type {
  DocumentData,
  QueryDocumentSnapshot,
  Firestore,
} from "firebase/firestore";
import {
  collection,
  getDocs,
  onSnapshot,
  orderBy,
  query,
  startAfter,
  limit,
} from "firebase/firestore";
import { useInfiniteQuery } from "@tanstack/react-query";
import type { ChatCoreConfig, ChatMessageV1 } from "../types";
import { canAccessThread } from "./useChatThreadAccess";
import { messagesColPath, newestWindowQuery } from "../firestore/queries";

type NewestWindowState = {
  ready: boolean;
  newestDesc: ChatMessageV1[];
  oldestDocInWindow: QueryDocumentSnapshot<DocumentData> | null;
};

export type UseChatMessagesResult = {
  allowed: boolean;
  isInitialLoading: boolean;
  messages: ChatMessageV1[];
  fetchOlder: () => Promise<void>;
  hasOlder: boolean;
  isFetchingOlder: boolean;
};

function mapMsg(
  doc: QueryDocumentSnapshot<DocumentData>,
  threadId: string
): ChatMessageV1 {
  const d = doc.data() as any;
  return {
    messageId: doc.id,
    threadId,
    createdAt:
      typeof d.createdAt === "number"
        ? d.createdAt
        : d.createdAt?.toMillis?.() ?? Date.now(),
    senderId: d.senderId,
    senderUsername: d.senderUsername,
    text: d.message ?? d.text ?? "",
    type: d.type,
    meta: d.meta,
  };
}

function dedupeAndSortAsc(all: ChatMessageV1[]) {
  const m = new Map<string, ChatMessageV1>();
  for (const x of all) m.set(x.messageId, x);
  return Array.from(m.values()).sort((a, b) => a.createdAt - b.createdAt);
}

function messagesCol(
  db: Firestore,
  chatCollection: string,
  threadId: string
) {
  return collection(db, ...messagesColPath(chatCollection, threadId));
}

export function useChatMessages(config: ChatCoreConfig): UseChatMessagesResult {
  const {
    db,
    chatCollection,
    threadId,
    pageSize = 20,
    currentUserId,
    isAdmin,
    threadAllowedUserIds,
    createdAtField = "createdAt",
  } = config;

  const allowed = React.useMemo(
    () =>
      canAccessThread({
        isAdmin,
        currentUserId,
        allowedUserIds: threadAllowedUserIds,
      }),
    [isAdmin, currentUserId, threadAllowedUserIds]
  );

  const [newest, setNewest] = React.useState<NewestWindowState>({
    ready: false,
    newestDesc: [],
    oldestDocInWindow: null,
  });

  // realtime newest window only
  React.useEffect(() => {
    if (!allowed) return;

    const q = newestWindowQuery(
      db,
      chatCollection,
      threadId,
      createdAtField,
      pageSize
    );

    const unsub = onSnapshot(q, (snap) => {
      const docs = snap.docs as QueryDocumentSnapshot<DocumentData>[];
      const mapped = docs.map((d) => mapMsg(d, threadId)); // desc
      setNewest({
        ready: true,
        newestDesc: mapped,
        oldestDocInWindow: docs[docs.length - 1] ?? null,
      });
    });

    return () => unsub();
  }, [allowed, db, chatCollection, threadId, createdAtField, pageSize]);

  // older pagination (beyond newest window)
  const older = useInfiniteQuery({
    queryKey: ["chat-core", "older", chatCollection, threadId, pageSize],
    enabled: allowed && newest.ready,
    initialPageParam: undefined as QueryDocumentSnapshot<DocumentData> | undefined,
    queryFn: async ({ pageParam }) => {
      const baseCol = messagesCol(db, chatCollection, threadId);

      const cursor =
        pageParam ?? (newest.oldestDocInWindow ?? undefined);

      if (!cursor) {
        return {
          itemsDesc: [] as ChatMessageV1[],
          nextCursor: undefined as QueryDocumentSnapshot<DocumentData> | undefined,
        };
      }

      const q = query(
        baseCol,
        orderBy(createdAtField, "desc"),
        startAfter(cursor),
        limit(pageSize)
      );

      const snap = await getDocs(q);
      const docs = snap.docs as QueryDocumentSnapshot<DocumentData>[];

      const itemsDesc = docs.map((d) => mapMsg(d, threadId)); // desc
      const nextCursor =
        docs.length === pageSize ? docs[docs.length - 1] : undefined;

      return { itemsDesc, nextCursor };
    },
    getNextPageParam: (last) => last.nextCursor,
  });

  const fetchOlder = React.useCallback(async () => {
    await older.fetchNextPage();
  }, [older.fetchNextPage]);

  const messages = React.useMemo(() => {
    if (!allowed) return [];
    const olderDesc = (older.data?.pages ?? []).flatMap((p) => p.itemsDesc);
    return dedupeAndSortAsc([...olderDesc, ...newest.newestDesc]);
  }, [allowed, older.data, newest.newestDesc]);

  return {
    allowed,
    isInitialLoading: allowed ? !newest.ready : false,
    messages,
    fetchOlder,
    hasOlder: Boolean(older.hasNextPage),
    isFetchingOlder: older.isFetchingNextPage,
  };
}


================================================================================
FILE PATH: packages/chat-core/src/hooks/useChatThreadAccess.ts
================================================================================
export function canAccessThread(args: {
    isAdmin: boolean;
    currentUserId: string;
    allowedUserIds?: string[];
  }) {
    const { isAdmin, currentUserId, allowedUserIds } = args;
    if (isAdmin) return true;
    if (!allowedUserIds) return false;
    return allowedUserIds.includes(currentUserId);
  }
  

================================================================================
FILE PATH: packages/chat-core/src/index.ts
================================================================================
export * from "./types";

export * from "./hooks/useChatMessages";
export * from "./hooks/useChatThreadAccess";

export * from "./ui/ChatShell";
export * from "./ui/MessageList";
export * from "./ui/Composer";
export * from "./ui/MessageItemDefault";
export * from "./ui/menus";

export * from "./templates/ChannelChat";
export * from "./templates/AdminThreadChat";
export * from "./templates/InviteChat";


================================================================================
FILE PATH: packages/chat-core/src/templates/AdminThreadChat.tsx
================================================================================
"use client";

import * as React from "react";
import type { ChatCoreConfig, ModerationHandlers } from "../types";
import { ChatShell } from "../ui/ChatShell";

export function AdminThreadChat(props: {
  config: ChatCoreConfig;
  onSend: (text: string) => void | Promise<void>;
  renderThreadActions?: () => React.ReactNode; // Close/Reopen/etc (app-owned)
  handlers?: ModerationHandlers;
}) {
  const { config, onSend, renderThreadActions, handlers } = props;
  return (
    <ChatShell
      config={config}
      header={<div className="font-medium">Support</div>}
      renderThreadActions={renderThreadActions}
      onSend={onSend}
      handlers={handlers}
    />
  );
}


================================================================================
FILE PATH: packages/chat-core/src/templates/ChannelChat.tsx
================================================================================
"use client";

import * as React from "react";
import type { ChatCoreConfig, ModerationHandlers, MessageRendererRegistry } from "../types";
import { ChatShell } from "../ui/ChatShell";

export function ChannelChat(props: {
  config: ChatCoreConfig;
  title?: string;
  onSend: (text: string) => void | Promise<void>;
  renderMessage?: (m: any) => React.ReactNode;
  messageRenderers?: MessageRendererRegistry;
  handlers?: ModerationHandlers;
}) {
  const { config, title, onSend, renderMessage, messageRenderers, handlers } = props;
  return (
    <ChatShell
      config={config}
      header={<div className="font-medium">{title ?? "Channel"}</div>}
      onSend={onSend}
      renderMessage={renderMessage}
      messageRenderers={messageRenderers}
      handlers={handlers}
    />
  );
}


================================================================================
FILE PATH: packages/chat-core/src/templates/InviteChat.tsx
================================================================================
"use client";

import * as React from "react";
import type { ChatCoreConfig, ModerationHandlers } from "../types";
import { ChatShell } from "../ui/ChatShell";

export function InviteChat(props: {
  config: ChatCoreConfig;
  onSend: (text: string) => void | Promise<void>;
  renderThreadActions?: () => React.ReactNode; // Accept/Decline/Finalize (app-owned)
  handlers?: ModerationHandlers;
}) {
  const { config, onSend, renderThreadActions, handlers } = props;
  return (
    <ChatShell
      config={config}
      header={<div className="font-medium">Invite</div>}
      renderThreadActions={renderThreadActions}
      onSend={onSend}
      handlers={handlers}
    />
  );
}


================================================================================
FILE PATH: packages/chat-core/src/types.ts
================================================================================
import type { Firestore } from "firebase/firestore";

export type ChatId = string;

export type ChatThreadV1 = {
  allowedUserIds: string[];
  participantUserIds?: string[];
  createdAt: number;       // millis
  lastMessageAt: number;   // millis
  status?: string;         // opaque to chat-core
  meta?: Record<string, unknown>; // opaque
};

export type ChatMessageV1 = {
  messageId: string;
  threadId: string;
  createdAt: number; // millis
  senderId: string;
  senderUsername?: string;
  text?: string;
  type?: string; // optional for renderer registry
  meta?: Record<string, unknown>;
};

export type ChatCollectionConfig = {
  /** top-level collection name, e.g. "projectChats" | "adminThreads" | "inviteChats" */
  chatCollection: string;
};

export type ChatCoreConfig = ChatCollectionConfig & {
  db: Firestore;
  pageSize?: number;

  threadId: string;
  currentUserId: string;
  isAdmin: boolean;

  /** If provided, used to gate access; otherwise only isAdmin applies */
  threadAllowedUserIds?: string[];

  /** Optional: tell chat-core which field to order by; must be indexed */
  createdAtField?: string; // default "createdAt"
};

export type ModerationHandlers = {
  onReportMessage?: (messageId: string, reason?: string) => void | Promise<void>;
  onReportThread?: (threadId: string, reason?: string) => void | Promise<void>;
  onDeleteMessage?: (messageId: string) => void | Promise<void>; // admin only (gated)
  onDeleteThread?: (threadId: string) => void | Promise<void>;   // admin only (gated)
};

export type MessageRenderer = (m: ChatMessageV1) => React.ReactNode;

export type MessageRendererRegistry = Record<string, MessageRenderer>;


================================================================================
FILE PATH: packages/chat-core/src/ui/ChatShell.tsx
================================================================================
"use client";

import * as React from "react";
import type { ChatCoreConfig, MessageRendererRegistry, ModerationHandlers } from "../types";
import { Card, CardHeader, CardContent, CardFooter, Skeleton } from "@ttt-productions/ui-core";
import { useChatMessages } from "../hooks/useChatMessages";
import { MessageList } from "./MessageList";
import { Composer } from "./Composer";
import { ThreadActions } from "./menus";

export function ChatShell(props: {
  config: ChatCoreConfig;

  header?: React.ReactNode;
  renderThreadActions?: () => React.ReactNode;

  onSend: (text: string) => void | Promise<void>;

  renderMessage?: (m: any) => React.ReactNode;
  messageRenderers?: MessageRendererRegistry;

  composerAutoFocus?: boolean;

  handlers?: ModerationHandlers;
}) {
  const {
    config,
    header,
    renderThreadActions,
    onSend,
    renderMessage,
    messageRenderers,
    composerAutoFocus = false,
    handlers
  } = props;

  const { allowed, isInitialLoading, messages, fetchOlder, hasOlder, isFetchingOlder } = useChatMessages(config);

  const [showScrollToBottom, setShowScrollToBottom] = React.useState(false);

  if (!allowed) {
    return <div className="p-4 text-sm opacity-70">You don’t have access to this thread.</div>;
  }

  if (isInitialLoading) {
    return (
      <Card className="w-full">
        <CardHeader className="space-y-2">
          <Skeleton className="h-5 w-40" />
          <Skeleton className="h-3 w-56" />
        </CardHeader>
        <CardContent>
          <Skeleton className="h-[240px] w-full" />
        </CardContent>
        <CardFooter>
          <Skeleton className="h-10 w-full" />
        </CardFooter>
      </Card>
    );
  }

  return (
    <Card className="w-full">
      {(header || renderThreadActions || handlers) && (
        <CardHeader className="flex flex-row items-start justify-between gap-4 space-y-0">
          <div>{header}</div>
          <div className="flex flex-col items-end gap-2">
            {renderThreadActions?.()}
            <ThreadActions threadId={config.threadId} isAdmin={config.isAdmin} handlers={handlers} />
          </div>
        </CardHeader>
      )}

      <CardContent className="p-0">
        <MessageList
          messages={messages}
          currentUserId={config.currentUserId}
          isAdmin={config.isAdmin}
          isFetchingOlder={isFetchingOlder}
          hasOlder={hasOlder}
          onLoadOlder={() => fetchOlder()}
          renderMessage={renderMessage}
          messageRenderers={messageRenderers}
          showScrollToBottom={showScrollToBottom}
          onScrollToBottom={() => setShowScrollToBottom(false)}
          handlers={handlers}
        />
      </CardContent>

      <CardFooter className="border-t">
        <div className="w-full">
          <Composer disabled={false} autoFocus={composerAutoFocus} onSend={onSend} />
        </div>
      </CardFooter>
    </Card>
  );
}


================================================================================
FILE PATH: packages/chat-core/src/ui/Composer.tsx
================================================================================
"use client";

import * as React from "react";
import { Button, Textarea, cn } from "@ttt-productions/ui-core";

export function Composer(props: {
  disabled?: boolean;
  autoFocus?: boolean;
  placeholder?: string;
  onSend: (text: string) => void | Promise<void>;
}) {
  const { disabled, autoFocus = false, placeholder = "Type a message...", onSend } = props;
  const [text, setText] = React.useState("");
  const ref = React.useRef<HTMLTextAreaElement>(null);

  // focus stability: never steal focus unless explicitly enabled
  React.useEffect(() => {
    if (!autoFocus) return;
    ref.current?.focus();
  }, [autoFocus]);

  const send = async () => {
    const v = text.trim();
    if (!v) return;
    setText("");
    await onSend(v);
  };

  return (
    <div className="flex items-end gap-2">
      <Textarea
        ref={ref}
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder={placeholder}
        disabled={disabled}
        rows={1}
        className={cn("min-h-[40px] resize-none")}
        onKeyDown={(e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            send();
          }
        }}
      />
      <Button
        type="button"
        variant="default"
        disabled={disabled || !text.trim()}
        onClick={send}
      >
        Send
      </Button>
    </div>
  );
}


================================================================================
FILE PATH: packages/chat-core/src/ui/menus.tsx
================================================================================
"use client";

import type { ModerationHandlers } from "../types";
import { Button } from "@ttt-productions/ui-core";

export function MessageActions(props: {
  messageId: string;
  isAdmin: boolean;
  handlers?: ModerationHandlers;
}) {
  const { messageId, isAdmin, handlers } = props;

  return (
    <div className="flex items-center gap-2">
      {handlers?.onReportMessage && (
        <Button
          type="button"
          variant="link"
          size="sm"
          className="h-auto p-0 text-xs opacity-70 hover:opacity-100"
          onClick={() => handlers.onReportMessage?.(messageId)}
        >
          Report
        </Button>
      )}
      {isAdmin && handlers?.onDeleteMessage && (
        <Button
          type="button"
          variant="link"
          size="sm"
          className="h-auto p-0 text-xs opacity-70 hover:opacity-100"
          onClick={() => handlers.onDeleteMessage?.(messageId)}
        >
          Delete
        </Button>
      )}
    </div>
  );
}

export function ThreadActions(props: {
  threadId: string;
  isAdmin: boolean;
  handlers?: ModerationHandlers;
}) {
  const { threadId, isAdmin, handlers } = props;

  return (
    <div className="flex items-center gap-3">
      {handlers?.onReportThread && (
        <Button
          type="button"
          variant="link"
          size="sm"
          className="h-auto p-0 text-xs opacity-70 hover:opacity-100"
          onClick={() => handlers.onReportThread?.(threadId)}
        >
          Report thread
        </Button>
      )}
      {isAdmin && handlers?.onDeleteThread && (
        <Button
          type="button"
          variant="link"
          size="sm"
          className="h-auto p-0 text-xs opacity-70 hover:opacity-100"
          onClick={() => handlers.onDeleteThread?.(threadId)}
        >
          Delete thread
        </Button>
      )}
    </div>
  );
}


================================================================================
FILE PATH: packages/chat-core/src/ui/MessageItemDefault.tsx
================================================================================
"use client";

import type { ChatMessageV1, ModerationHandlers } from "../types";
import { cn } from "@ttt-productions/ui-core";
import { MessageActions } from "./menus";

export function MessageItemDefault(props: {
  m: ChatMessageV1;
  currentUserId: string;
  isAdmin: boolean;
  handlers?: ModerationHandlers;
}) {
  const { m, currentUserId, isAdmin, handlers } = props;
  const mine = m.senderId === currentUserId;

  return (
    <div
      className={cn(
        "flex flex-col w-fit max-w-[85%]",
        mine ? "ml-auto items-end" : "mr-auto items-start"
      )}
    >
      <div className={cn("p-3 rounded-lg", mine ? "bg-primary/10" : "bg-muted")}>
        <div className="flex items-center gap-2 text-xs opacity-80 mb-1">
          <span className="font-medium">{m.senderUsername ?? "User"}</span>
          <span>·</span>
          <span>{new Date(m.createdAt).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })}</span>
        </div>
        {m.text && <p className="text-sm whitespace-pre-wrap">{m.text}</p>}
      </div>

      <div className="mt-1">
        <MessageActions messageId={m.messageId} isAdmin={isAdmin} handlers={handlers} />
      </div>
    </div>
  );
}


================================================================================
FILE PATH: packages/chat-core/src/ui/MessageList.tsx
================================================================================
"use client";

import * as React from "react";
import type { ChatMessageV1, MessageRendererRegistry, ModerationHandlers } from "../types";
import { Button } from "@ttt-productions/ui-core";
import { MessageItemDefault } from "./MessageItemDefault";

export function MessageList(props: {
  messages: ChatMessageV1[];
  currentUserId: string;
  isAdmin: boolean;

  isFetchingOlder?: boolean;
  hasOlder?: boolean;
  onLoadOlder?: () => void;

  renderMessage?: (m: ChatMessageV1) => React.ReactNode;
  messageRenderers?: MessageRendererRegistry;

  showScrollToBottom?: boolean;
  onScrollToBottom?: () => void;

  handlers?: ModerationHandlers;
}) {
  const {
    messages,
    currentUserId,
    isAdmin,
    isFetchingOlder,
    hasOlder,
    onLoadOlder,
    renderMessage,
    messageRenderers,
    showScrollToBottom,
    onScrollToBottom,
    handlers
  } = props;

  const scrollRef = React.useRef<HTMLDivElement>(null);
  const topSentinelRef = React.useRef<HTMLDivElement>(null);

  const isAtBottomRef = React.useRef(true);
  const prevScrollHeightRef = React.useRef<number | null>(null);
  const prevCountRef = React.useRef(0);

  React.useEffect(() => {
    const root = scrollRef.current;
    const target = topSentinelRef.current;
    if (!root || !target) return;
    if (typeof IntersectionObserver === "undefined") return;

    const io = new IntersectionObserver(
      (entries) => {
        const e = entries[0];
        if (!e?.isIntersecting) return;
        if (!hasOlder || isFetchingOlder) return;

        prevScrollHeightRef.current = root.scrollHeight;
        onLoadOlder?.();
      },
      { root, threshold: 0 }
    );

    io.observe(target);
    return () => io.disconnect();
  }, [hasOlder, isFetchingOlder, onLoadOlder]);

  React.useLayoutEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const count = messages.length;
    const prev = prevCountRef.current;

    if (prev === 0 && count > 0) {
      el.scrollTop = el.scrollHeight;
      isAtBottomRef.current = true;
    } else if (count > prev && prevScrollHeightRef.current != null) {
      const diff = el.scrollHeight - prevScrollHeightRef.current;
      el.scrollTop += diff;
      prevScrollHeightRef.current = null;
    } else if (count > prev && isAtBottomRef.current) {
      el.scrollTo({ top: el.scrollHeight, behavior: "smooth" });
    }

    prevCountRef.current = count;
  }, [messages]);

  const onScroll = (e: React.UIEvent<HTMLDivElement>) => {
    const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
    isAtBottomRef.current = scrollHeight - (scrollTop + clientHeight) < 50;
  };

  let lastDay: string | null = null;

  return (
    <div className="relative">
      <div ref={scrollRef} className="h-[400px] overflow-y-auto p-4" onScroll={onScroll}>
        {isFetchingOlder && <div className="text-center text-xs opacity-70 mb-2">Loading…</div>}

        <div ref={topSentinelRef} />

        {messages.length === 0 ? (
          <div className="h-full flex items-center justify-center text-sm opacity-70">No messages yet</div>
        ) : (
          <div className="flex flex-col gap-3">
            {messages.map((m) => {
              const day = new Date(m.createdAt).toDateString();
              const showDay = day !== lastDay;
              lastDay = day;

              const byType =
                m.type && messageRenderers?.[m.type] ? messageRenderers[m.type]!(m) : null;

              const body =
                renderMessage?.(m) ??
                byType ?? (
                  <MessageItemDefault
                    m={m}
                    currentUserId={currentUserId}
                    isAdmin={isAdmin}
                    handlers={handlers}
                  />
                );

              return (
                <React.Fragment key={m.messageId}>
                  {showDay && (
                    <div className="my-2 flex justify-center">
                      {/* theme-core: components.css */}
                      <div className="chat-date-separator">
                        {new Date(m.createdAt).toLocaleDateString()}
                      </div>
                    </div>
                  )}
                  {body}
                </React.Fragment>
              );
            })}
          </div>
        )}
      </div>

      {showScrollToBottom && (
        <Button
          type="button"
          variant="outline"
          size="icon"
          className="absolute bottom-4 left-1/2 -translate-x-1/2 rounded-full shadow-sm"
          onClick={onScrollToBottom}
        >
          ↓
        </Button>
      )}
    </div>
  );
}


================================================================================
FILE PATH: packages/chat-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "jsx": "react-jsx",
    "composite": true
  },
  "references": [{ "path": "../ui-core" }],
  "include": ["src"]
}


================================================================================
FILE PATH: packages/file-input/package.json
================================================================================
{
    "name": "@ttt-productions/file-input",
    "version": "0.0.0",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/ttt-productions/ttt-packages.git",
      "directory": "packages/file-input"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
      "dist"
    ],
    "exports": {
      ".": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    },
    "scripts": {
      "build": "tsc",
      "clean": "rm -rf dist *.tsbuildinfo",
      "typecheck": "tsc --noEmit",
      "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
      "react": ">=18.0.0",
      "react-dom": ">=18.0.0",
      "@ttt-productions/ui-core": ">=0.0.0",
      "@ttt-productions/media-contracts": ">=0.0.0"
    },
    "dependencies": {
      "react-easy-crop": "^5.5.0"
    },
    "devDependencies": {
      "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
  }
  

================================================================================
FILE PATH: packages/file-input/src/components/audio-input.tsx
================================================================================
import type { FileInputProps } from "../types";
import { FileInput } from "./file-input";

export function AudioInput(props: Omit<FileInputProps, "acceptTypes">) {
  return <FileInput {...props} acceptTypes={["audio"]} />;
}


================================================================================
FILE PATH: packages/file-input/src/components/auto-format-modal.tsx
================================================================================
"use client";

import {
  Button,
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@ttt-productions/ui-core";

export interface AutoFormatModalProps {
  open: boolean;
  title?: string;
  description?: string;
  proceedLabel?: string;
  cancelLabel?: string;
  onProceed: () => void;
  onCancel: () => void;
}

export function AutoFormatModal(props: AutoFormatModalProps) {
  const {
    open,
    title = "We’ll auto-format this video",
    description = "This video doesn’t match the required format. We can auto-crop/resize/transcode after upload. This may take longer.",
    proceedLabel = "Proceed (Auto-format)",
    cancelLabel = "Cancel",
    onProceed,
    onCancel,
  } = props;

  return (
    <Dialog open={open} onOpenChange={(v) => !v && onCancel()}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>{description}</DialogDescription>
        </DialogHeader>

        <DialogFooter className="flex-row justify-end gap-2">
          <Button variant="destructive" onClick={onCancel}>
            {cancelLabel}
          </Button>
          <Button variant="default" onClick={onProceed}>
            {proceedLabel}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


================================================================================
FILE PATH: packages/file-input/src/components/file-input.tsx
================================================================================
"use client";

import { useCallback, useMemo, useRef, useState, useId } from "react";
import { getSimplifiedMediaType, type SimplifiedMediaType } from "@ttt-productions/media-contracts";
import { Alert, AlertDescription, Button, Card, Input, Progress, cn } from "@ttt-productions/ui-core";
import { Info, X, Upload, Film, Music, Paperclip, AlertTriangle, Loader2 } from "lucide-react";

import type { FileInputError, FileInputProps } from "../types";
import { validateMediaDuration } from "../lib/validate-media-duration";
import { ImageCropperModal } from "./image-cropper-modal";

const MIME_MAP: Record<SimplifiedMediaType, string> = {
  image: "image/jpeg, image/png, image/gif, image/webp, image/svg+xml, image/bmp, image/avif",
  video: "video/*, .mkv",
  audio: "audio/*",
  other: ".pdf, .doc, .docx"
};

function err(code: FileInputError["code"], message: string, details?: Record<string, unknown>): FileInputError {
  return { code, message, details };
}

export function FileInput(props: FileInputProps) {
  const {
    acceptTypes,
    maxSizeMB,
    selectedFile,
    onChange,
    onError,
    isLoading = false,
    disabled = false,
    buttonLabel = "Upload File",
    className,
    uploadProgress = null,
    variant = "default",
    size = "default",
    cropConfig,
    videoMaxDurationSec,
    audioMaxDurationSec,
    backendProcessing,
    defaultShowDetails = false,
  } = props;

  const fileInputRef = useRef<HTMLInputElement>(null);
  const uniqueId = useId();
  const inputId = `file-input-${uniqueId}`;

  const [internalSelected, setInternalSelected] = useState<File | null>(null);
  const fileValue = selectedFile !== undefined ? selectedFile : internalSelected;

  const [localError, setLocalError] = useState<FileInputError | null>(null);

  const [isCropperOpen, setIsCropperOpen] = useState(false);
  const [imageToCrop, setImageToCrop] = useState<string | null>(null);

  const [showDetails, setShowDetails] = useState(defaultShowDetails);

  const acceptString = useMemo(
    () => (acceptTypes.length ? acceptTypes.map((t) => MIME_MAP[t]).join(", ") : undefined),
    [acceptTypes]
  );

  const detailsDescriptionParts = useMemo(() => {
    const parts: string[] = [];

    if (cropConfig) {
      const ratioDisplay = cropConfig.aspectRatioDisplay || `${cropConfig.aspectRatio.toFixed(2)}:1`;
      parts.push(`Image will be cropped to a ${ratioDisplay} rect (${cropConfig.outputWidth}x${cropConfig.outputHeight}px).`);
    }

    const sizeParts = acceptTypes
      .map((t) => (maxSizeMB[t] ? `${t.charAt(0).toUpperCase() + t.slice(1)} (${maxSizeMB[t]}MB)` : null))
      .filter(Boolean) as string[];

    if (sizeParts.length) parts.push(`Max sizes: ${sizeParts.join(", ")}.`);

    if (backendProcessing?.image && acceptTypes.includes("image")) {
      const { maxWidth, maxHeight, aspectRatio, quality } = backendProcessing.image;
      const aspectInfo = aspectRatio ? ` (${aspectRatio})` : "";
      const qualityInfo = quality ? `, ${quality}% quality` : "";
      parts.push(`Backend: Images optimized to ${maxWidth}x${maxHeight}${aspectInfo}${qualityInfo}.`);
    }

    if (backendProcessing?.video && acceptTypes.includes("video")) {
      const { maxWidth, maxHeight, aspectRatio, codec } = backendProcessing.video;
      const aspectInfo = aspectRatio ? ` (${aspectRatio})` : "";
      const codecInfo = codec ? `, ${codec}` : "";
      parts.push(`Backend: Videos optimized to ${maxWidth}x${maxHeight}${aspectInfo}${codecInfo}.`);
    }

    if (backendProcessing?.audio && acceptTypes.includes("audio")) {
      const { bitrate, codec } = backendProcessing.audio;
      const bitrateInfo = bitrate ? `${bitrate} bitrate` : "";
      const codecInfo = codec ? ` (${codec})` : "";
      parts.push(`Backend: Audio optimized to ${bitrateInfo}${codecInfo}.`);
    }

    if (videoMaxDurationSec) parts.push(`Max video duration: ${videoMaxDurationSec}s.`);
    if (audioMaxDurationSec) parts.push(`Max audio duration: ${audioMaxDurationSec}s.`);

    return parts;
  }, [acceptTypes, maxSizeMB, cropConfig, backendProcessing, videoMaxDurationSec, audioMaxDurationSec]);

  const getUploadIcon = () => {
    if (acceptTypes.includes("image")) return <Upload className="mr-2 icon-xs" />;
    if (acceptTypes.includes("video")) return <Film className="mr-2 icon-xs" />;
    if (acceptTypes.includes("audio")) return <Music className="mr-2 icon-xs" />;
    return <Upload className="mr-2 icon-xs" />;
  };

  const clearNative = () => {
    if (fileInputRef.current) fileInputRef.current.value = "";
  };

  const emitError = (e: FileInputError, type: SimplifiedMediaType = "other") => {
    setLocalError(e);
    onError?.(e);
    onChange({ type, error: e });
  };

  const handleClear = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.stopPropagation();
    e.preventDefault();
    setLocalError(null);
    setInternalSelected(null);
    clearNative();
    onChange({ type: "other" });
  };

  const handleFileChange = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    clearNative();
    setLocalError(null);

    if (!file) {
      setInternalSelected(null);
      onChange({ type: "other" });
      return;
    }

    const fileType = getSimplifiedMediaType(file);
    if (acceptTypes.length && !acceptTypes.includes(fileType)) {
      emitError(err("invalid_type", `Invalid file type. Allowed: ${acceptTypes.join(", ")}.`), fileType);
      return;
    }

    const maxBytes = (maxSizeMB[fileType] ?? Infinity) * 1024 * 1024;
    if (file.size > maxBytes) {
      emitError(err("too_large", `File too large. Max ${maxSizeMB[fileType]}MB for ${fileType}.`, { size: file.size, maxBytes }), fileType);
      return;
    }

    if (fileType === "video" && videoMaxDurationSec) {
      const ok = await validateMediaDuration(file, videoMaxDurationSec);
      if (!ok) {
        emitError(err("too_long", `Video too long. Max ${videoMaxDurationSec} seconds.`), fileType);
        return;
      }
    }

    if (fileType === "audio" && audioMaxDurationSec) {
      const ok = await validateMediaDuration(file, audioMaxDurationSec);
      if (!ok) {
        emitError(err("too_long", `Audio too long. Max ${audioMaxDurationSec} seconds.`), fileType);
        return;
      }
    }

    // cropping path
    if (cropConfig && fileType === "image") {
      const reader = new FileReader();
      reader.onload = () => {
        setImageToCrop(reader.result as string);
        setIsCropperOpen(true);
      };
      reader.onerror = () => {
        emitError(err("read_failed", "Failed to read image for cropping."));
      };
      reader.readAsDataURL(file);
      setInternalSelected(file);
      return;
    }

    // normal selection
    setInternalSelected(file);
    onChange({ type: fileType, file, previewUrl: URL.createObjectURL(file) });
  }, [acceptTypes, maxSizeMB, cropConfig, videoMaxDurationSec, audioMaxDurationSec, onChange]);

  const handleCropComplete = (blob: Blob | null) => {
    setIsCropperOpen(false);

    const original = internalSelected;
    setImageToCrop(null);

    if (!blob) {
      emitError(err("crop_failed", "Cropping failed."), "image");
      return;
    }

    onChange({
      type: "image",
      file: original ?? undefined,
      blob,
      previewUrl: URL.createObjectURL(blob),
    });
  };

  const isUploading = typeof uploadProgress === "number" && isLoading;

  return (
    <div className={cn("relative w-full", className)}>
      {localError && (
        <Alert variant="destructive" className="mb-2">
          <AlertTriangle className="icon-xs" />
          <AlertDescription>{localError.message}</AlertDescription>
        </Alert>
      )}

      <Input
        id={inputId}
        type="file"
        accept={acceptString}
        onChange={handleFileChange}
        className="hidden"
        disabled={disabled || isLoading}
        ref={fileInputRef}
      />

      <div className="flex items-center gap-2">
        <label htmlFor={inputId} className="w-full flex-grow">
          <Button
            asChild
            disabled={disabled || isLoading}
            variant={variant}
            size={size}
            className={cn("w-full relative overflow-hidden cursor-pointer", { "icon-xl p-0": size === "icon" })}
          >
            <span className="relative w-full h-full center-row">
              {isUploading && (
                <Progress value={uploadProgress ?? 0} className="absolute left-0 top-0 h-full w-full z-0 bg-accent" />
              )}

              <span className="z-10 center-row w-full">
                {isLoading ? (
                  <><Loader2 className="mr-2 spinner-xs" /> {isUploading ? `${(uploadProgress ?? 0).toFixed(0)}%` : "Processing..."}</>
                ) : fileValue ? (
                  <span className="flex items-center justify-between w-full">
                    <span className="truncate pr-2">{fileValue.name}</span>
                    <Button variant="ghost" size="icon" className="icon-sm hover:bg-destructive/20 shrink-0" onClick={handleClear}>
                      <X className="icon-xs" />
                    </Button>
                  </span>
                ) : (
                  <>
                    {buttonLabel === "Attach"
                      ? <><Paperclip className="mr-2 icon-xs" /> {buttonLabel}</>
                      : <>{getUploadIcon()} {buttonLabel}</>}
                  </>
                )}
              </span>
            </span>
          </Button>
        </label>

        {detailsDescriptionParts.length > 0 && size !== "icon" && (
          <Button
            type="button"
            variant="default"
            size="icon"
            onClick={() => setShowDetails((p) => !p)}
            aria-label="Show file processing details"
            className="flex-shrink-0 icon-xl"
          >
            <Info className="icon-sm" />
          </Button>
        )}
      </div>

      {showDetails && detailsDescriptionParts.length > 0 && size !== "icon" && (
        <Card className="page-card w-full mt-2">
          <div className="text-center p-2 space-y-0.5">
            {detailsDescriptionParts.map((part, i) => (
              <p key={i} className="text-small font-bold">{part}</p>
            ))}
          </div>
        </Card>
      )}

      {cropConfig && imageToCrop && (
        <ImageCropperModal
          isOpen={isCropperOpen}
          onClose={() => {
            setIsCropperOpen(false);
            setImageToCrop(null);
          }}
          imageSrc={imageToCrop}
          aspectRatio={cropConfig.aspectRatio}
          shape={cropConfig.shape}
          outputWidth={cropConfig.outputWidth}
          outputHeight={cropConfig.outputHeight}
          onCropComplete={handleCropComplete}
        />
      )}
    </div>
  );
}


================================================================================
FILE PATH: packages/file-input/src/components/image-cropper-modal.tsx
================================================================================
"use client";

import { useState, useCallback } from "react";
import Cropper, { type Area } from "react-easy-crop";
import { Button, Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription, Slider } from "@ttt-productions/ui-core";
import { getCroppedImg } from "../lib/image-utils";

export interface ImageCropperModalProps {
  isOpen: boolean;
  onClose: () => void;
  imageSrc: string | null;
  aspectRatio: number;
  shape: "rect" | "round";
  outputWidth: number;
  outputHeight: number;
  onCropComplete: (croppedBlob: Blob | null) => void;
}

export function ImageCropperModal(props: ImageCropperModalProps) {
  const { isOpen, onClose, imageSrc, aspectRatio, shape, outputWidth, outputHeight, onCropComplete } = props;

  const [crop, setCrop] = useState({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(1);
  const [croppedAreaPixels, setCroppedAreaPixels] = useState<Area | null>(null);

  const handleCropComplete = useCallback((_a: Area, pixels: Area) => {
    setCroppedAreaPixels(pixels);
  }, []);

  const handleConfirm = useCallback(async () => {
    if (!imageSrc || !croppedAreaPixels) return;
    try {
      const blob = await getCroppedImg(imageSrc, croppedAreaPixels, 0, { horizontal: false, vertical: false }, outputWidth, outputHeight);
      onCropComplete(blob);
      onClose();
    } catch {
      onCropComplete(null);
    }
  }, [imageSrc, croppedAreaPixels, onCropComplete, onClose, outputWidth, outputHeight]);

  if (!imageSrc) return null;

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Crop Image</DialogTitle>
          <DialogDescription>Adjust the crop area and zoom level to select the desired portion of your image.</DialogDescription>
        </DialogHeader>

        <div className="relative h-64 w-full bg-muted">
          <Cropper
            image={imageSrc}
            crop={crop}
            zoom={zoom}
            aspect={aspectRatio}
            cropShape={shape}
            showGrid={false}
            onCropChange={setCrop}
            onZoomChange={setZoom}
            onCropComplete={handleCropComplete}
          />
        </div>

        <div className="stack-2">
          <label htmlFor="zoom" className="text-small">Zoom</label>
          <Slider id="zoom" min={1} max={3} step={0.1} value={[zoom]} onValueChange={(v) => setZoom(v[0])} />
        </div>

        <DialogFooter className="flex-row justify-end gap-2">
          <Button variant="destructive" onClick={onClose}>Cancel</Button>
          <Button variant="default" onClick={handleConfirm}>Confirm</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


================================================================================
FILE PATH: packages/file-input/src/components/image-input.tsx
================================================================================
import type { FileInputProps } from "../types";
import { FileInput } from "./file-input";

export function ImageInput(props: Omit<FileInputProps, "acceptTypes">) {
  return <FileInput {...props} acceptTypes={["image"]} />;
}


================================================================================
FILE PATH: packages/file-input/src/components/media-constraints-hint.tsx
================================================================================
"use client";

import type { MediaProcessingSpec } from "@ttt-productions/media-contracts";
import { Badge, Card, cn } from "@ttt-productions/ui-core";

export interface MediaConstraintsHintProps {
  spec: MediaProcessingSpec;
  className?: string;
  title?: string;
}

function fmtBytes(bytes?: number) {
  if (!bytes || bytes <= 0) return null;
  const mb = bytes / (1024 * 1024);
  if (mb < 1024) return `${Math.round(mb)}MB`;
  const gb = mb / 1024;
  return `${gb.toFixed(1)}GB`;
}

function fmtAspect(x?: number) {
  if (!x) return null;
  // show common approx ratios if close
  const candidates: Array<[string, number]> = [
    ["1:1", 1],
    ["4:5", 4 / 5],
    ["3:4", 3 / 4],
    ["9:16", 9 / 16],
    ["16:9", 16 / 9],
  ];
  for (const [label, v] of candidates) {
    if (Math.abs(x - v) <= 0.02) return label;
  }
  return `${x.toFixed(3)}`;
}

export function MediaConstraintsHint(props: MediaConstraintsHintProps) {
  const { spec, className, title = "Upload requirements" } = props;

  const acceptKinds = spec.accept?.kinds?.length ? spec.accept.kinds.join(", ") : "any";
  const acceptMimes = spec.accept?.mimes?.length ? spec.accept.mimes.join(", ") : "any";

  const maxBytes = fmtBytes(spec.maxBytes);
  const maxDur =
    spec.maxDurationSec ?? spec.video?.maxDurationSec ?? spec.audio?.maxDurationSec ?? undefined;

  const requiredAspect = fmtAspect(spec.requiredAspectRatio ?? spec.imageCrop?.aspectRatio);
  const requiredDims =
    spec.requiredWidth && spec.requiredHeight ? `${spec.requiredWidth}×${spec.requiredHeight}` : null;

  const videoOri = spec.videoOrientation && spec.videoOrientation !== "any" ? spec.videoOrientation : null;

  const cropDims =
    spec.imageCrop ? `${spec.imageCrop.outputWidth}×${spec.imageCrop.outputHeight}` : null;

  const willAutoFormat = !!spec.allowAutoFormat;

  const items: Array<{ k: string; v: string | null }> = [
    { k: "Kind", v: acceptKinds },
    { k: "Types", v: acceptMimes },
    { k: "Max size", v: maxBytes },
    { k: "Max length", v: maxDur ? `${maxDur}s` : null },
    { k: "Orientation", v: videoOri },
    { k: "Aspect", v: requiredAspect },
    { k: "Exact size", v: requiredDims },
    { k: "Crop output", v: cropDims },
    { k: "Auto-format", v: willAutoFormat ? "yes" : null },
  ].filter((x) => x.v);

  if (!items.length) return null;

  return (
    <Card className={cn("p-3", className)}>
      <div className="flex items-center justify-between gap-2">
        <div className="text-sm font-medium">{title}</div>
        {willAutoFormat ? <Badge variant="secondary">Auto-format supported</Badge> : null}
      </div>

      <div className="mt-2 flex flex-wrap gap-2">
        {items.map((it) => (
          <Badge key={it.k} variant="outline" className="gap-1">
            <span className="text-muted-foreground">{it.k}:</span>
            <span>{it.v}</span>
          </Badge>
        ))}
      </div>

      {spec.imageCrop ? (
        <div className="mt-2 text-xs text-muted-foreground">
          Images will be cropped to {fmtAspect(spec.imageCrop.aspectRatio)} and exported as{" "}
          {(spec.imageCrop.format ?? "jpeg").toUpperCase()}
          {spec.imageCrop.quality ? ` @ ${spec.imageCrop.quality}%` : ""}.
        </div>
      ) : null}

      {spec.allowAutoFormat ? (
        <div className="mt-2 text-xs text-muted-foreground">
          If your video doesn’t match the format, we’ll ask before uploading and then auto-format it in processing.
        </div>
      ) : null}
    </Card>
  );
}


================================================================================
FILE PATH: packages/file-input/src/components/media-input.tsx
================================================================================
"use client";

import React, { useCallback, useId, useMemo, useRef, useState } from "react";
import type { MediaCropSpec, MediaProcessingSpec, VideoOrientation } from "@ttt-productions/media-contracts";
import { getSimplifiedMediaType } from "@ttt-productions/media-contracts";
import { Info, Camera, Mic, Video, Upload, X } from "lucide-react";

import {
  Alert,
  AlertDescription,
  Button,
  Card,
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  Input,
  cn,
} from "@ttt-productions/ui-core";

import type { FileInputError, MediaInputProps, SelectedMediaMeta } from "../types";
import { AutoFormatModal } from "./auto-format-modal";
import { ImageCropperModal } from "./image-cropper-modal";
import { MediaConstraintsHint } from "./media-constraints-hint";
import { readMediaMeta } from "../lib/read-media-meta";
import { validateMediaDuration } from "../lib/validate-media-duration";

function err(code: FileInputError["code"], message: string, details?: Record<string, unknown>): FileInputError {
  return { code, message, details };
}

function hasConstraints(spec: MediaProcessingSpec): boolean {
  return Boolean(
    spec.accept?.kinds?.length ||
      spec.accept?.mimes?.length ||
      spec.maxBytes ||
      spec.maxDurationSec ||
      spec.video?.maxDurationSec ||
      spec.audio?.maxDurationSec ||
      (spec.videoOrientation && spec.videoOrientation !== "any") ||
      spec.requiredAspectRatio ||
      (spec.requiredWidth && spec.requiredHeight) ||
      spec.imageCrop ||
      spec.allowAutoFormat
  );
}

function matchMime(accepted: string, actual: string): boolean {
  const a = accepted.trim().toLowerCase();
  const m = actual.trim().toLowerCase();
  if (!a) return true;
  if (a === "*/*") return true;
  if (a.endsWith("/*")) return m.startsWith(a.slice(0, -1));
  return a === m;
}

function accepts(spec: MediaProcessingSpec, file: File): boolean {
  const accept = spec.accept;
  if (!accept) return true;

  const kinds = accept.kinds?.filter(Boolean) ?? [];
  const mimes = accept.mimes?.filter(Boolean) ?? [];

  const simplified = getSimplifiedMediaType(file);
  const kind: "image" | "video" | "audio" | "file" =
    simplified === "image" || simplified === "video" || simplified === "audio" ? simplified : "file";

  const kindOk = kinds.length === 0 ? true : kinds.includes(kind);
  if (!kindOk) return false;

  // If mimes list is empty, accept anything (including unknown file.type)
  if (mimes.length === 0) return true;

  // If mimes list exists but browser doesn't know type, reject
  if (!file.type) return false;

  return mimes.some((a) => matchMime(a, file.type));
}

function computeAspect(width?: number, height?: number): number | undefined {
  if (!width || !height) return undefined;
  return width / height;
}

function orientationOk(required: VideoOrientation | undefined, actual: VideoOrientation | undefined): boolean {
  if (!required || required === "any") return true;
  if (!actual || actual === "any") return true; // treat square/unknown as ok
  return required === actual;
}

function aspectOk(required: number | undefined, actual: number | undefined): boolean {
  if (!required) return true;
  if (!actual) return false;
  return Math.abs(actual - required) <= 0.02; // ~2% tolerance
}

export function MediaInput(props: MediaInputProps) {
  const { spec, cropOverride, disabled = false, isLoading = false, className, buttonLabel = "Select file", onChange } =
    props;

  const id = useId();
  const pickerRef = useRef<HTMLInputElement>(null);
  const photoRef = useRef<HTMLInputElement>(null);

  const cropSpec: MediaCropSpec | undefined = cropOverride ?? spec.imageCrop;

  const [localError, setLocalError] = useState<FileInputError | null>(null);

  const [showInfo, setShowInfo] = useState(false);
  const showInfoToggle = hasConstraints(spec);

  const [cropOpen, setCropOpen] = useState(false);
  const [cropSrc, setCropSrc] = useState<string | null>(null);
  const [pendingCropFile, setPendingCropFile] = useState<File | null>(null);

  const [autoOpen, setAutoOpen] = useState(false);
  const [pendingAutoFile, setPendingAutoFile] = useState<{ file: File; meta: SelectedMediaMeta } | null>(null);

  const [recordOpen, setRecordOpen] = useState(false);
  const [recordKind, setRecordKind] = useState<"audio" | "video">("video");
  const [recording, setRecording] = useState(false);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const recordStreamRef = useRef<MediaStream | null>(null);
  const recordChunksRef = useRef<BlobPart[]>([]);
  const [recordPreviewUrl, setRecordPreviewUrl] = useState<string | null>(null);

  const acceptAttr = useMemo(() => {
    const m = spec.accept?.mimes?.filter(Boolean) ?? [];
    const k = spec.accept?.kinds?.filter(Boolean) ?? [];
    if (m.length) return m.join(", ");
    if (k.includes("image") && k.length === 1) return "image/*";
    if (k.includes("video") && k.length === 1) return "video/*";
    if (k.includes("audio") && k.length === 1) return "audio/*";
    return undefined; // accept anything
  }, [spec]);

  const emit = useCallback(
    (payload: {
      file?: File;
      previewUrl?: string;
      meta?: SelectedMediaMeta;
      autoFormat?: boolean;
      croppedBlob?: Blob;
      error?: FileInputError;
    }) => {
      onChange({ spec, ...payload });
    },
    [onChange, spec]
  );

  const fail = useCallback(
    (e: FileInputError) => {
      setLocalError(e);
      emit({ error: e });
    },
    [emit]
  );

  const resetRecordState = useCallback(() => {
    setRecording(false);
    mediaRecorderRef.current = null;

    const s = recordStreamRef.current;
    recordStreamRef.current = null;
    if (s) s.getTracks().forEach((t) => t.stop());

    recordChunksRef.current = [];
  }, []);

  const stopRecording = useCallback(() => {
    try {
      const mr = mediaRecorderRef.current;
      if (mr && mr.state === "recording") mr.stop();
    } finally {
      resetRecordState();
    }
  }, [resetRecordState]);

  const handleSelected = useCallback(
    async (file: File, previewUrl?: string) => {
      setLocalError(null);

      if (!accepts(spec, file)) {
        fail(err("invalid_type", "Invalid file type for this upload."));
        return;
      }

      const meta = await readMediaMeta(file);

      // bytes
      if (spec.maxBytes && file.size > spec.maxBytes) {
        fail(
          err("too_large", `File too large. Max ${Math.round(spec.maxBytes / 1024 / 1024)}MB.`, {
            size: file.size,
            maxBytes: spec.maxBytes,
          })
        );
        return;
      }

      // duration
      const maxDur = spec.maxDurationSec ?? spec.video?.maxDurationSec ?? spec.audio?.maxDurationSec;
      if ((meta.kind === "video" || meta.kind === "audio") && maxDur) {
        const ok = await validateMediaDuration(file, maxDur);
        if (!ok) {
          fail(err("too_long", `Media too long. Max ${maxDur} seconds.`));
          return;
        }
      }

      // image crop enforcement
      if (meta.kind === "image" && cropSpec) {
        const reader = new FileReader();
        reader.onload = () => {
          setPendingCropFile(file);
          setCropSrc(reader.result as string);
          setCropOpen(true);
        };
        reader.onerror = () => fail(err("read_failed", "Failed to read image for cropping."));
        reader.readAsDataURL(file);
        return;
      }

      // video uniform enforcement (orientation/aspect/dimensions)
      if (meta.kind === "video") {
        const requiredOri = spec.videoOrientation;
        const requiredAspect = spec.requiredAspectRatio;
        const requiredW = spec.requiredWidth;
        const requiredH = spec.requiredHeight;

        const actualOri = meta.orientation;
        const actualAspect = computeAspect(meta.width, meta.height);

        const okOri = orientationOk(requiredOri, actualOri);
        const okAspect = aspectOk(requiredAspect, actualAspect);
        const okDims = !requiredW || !requiredH ? true : meta.width === requiredW && meta.height === requiredH;

        if (!okOri || !okAspect || !okDims) {
          if (spec.allowAutoFormat) {
            setPendingAutoFile({ file, meta });
            setAutoOpen(true);
            return;
          }

          if (!okOri) {
            fail(
              err("orientation_mismatch", "Video orientation does not match the required format.", {
                requiredOri,
                actualOri,
              })
            );
            return;
          }
          if (!okAspect) {
            fail(
              err("aspect_ratio_mismatch", "Video aspect ratio does not match the required format.", {
                requiredAspect,
                actualAspect,
              })
            );
            return;
          }
          if (!okDims) {
            fail(
              err("dimensions_mismatch", "Video dimensions do not match the required format.", {
                requiredW,
                requiredH,
                width: meta.width,
                height: meta.height,
              })
            );
            return;
          }
        }
      }

      emit({ file, previewUrl, meta });
    },
    [spec, cropSpec, emit, fail]
  );

  const onPick = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      e.target.value = "";
      if (!file) return;
      const url = URL.createObjectURL(file);
      await handleSelected(file, url);
    },
    [handleSelected]
  );

  const onCropComplete = useCallback(
    (blob: Blob | null) => {
      setCropOpen(false);

      const original = pendingCropFile;
      setPendingCropFile(null);

      if (!blob || !original) {
        fail(err("crop_failed", "Cropping failed."));
        setCropSrc(null);
        return;
      }

      const type = blob.type || "image/jpeg";
      const name = original.name?.replace(/\.[^/.]+$/, "") || "image";
      const ext = type.includes("png")
        ? "png"
        : type.includes("webp")
          ? "webp"
          : type.includes("avif")
            ? "avif"
            : "jpg";

      const croppedFile = new File([blob], `${name}.cropped.${ext}`, { type });

      const url = URL.createObjectURL(croppedFile);
      readMediaMeta(croppedFile).then((meta) => emit({ file: croppedFile, previewUrl: url, meta, croppedBlob: blob }));

      setCropSrc(null);
    },
    [emit, fail, pendingCropFile]
  );

  const proceedAuto = useCallback(() => {
    const p = pendingAutoFile;
    setAutoOpen(false);
    setPendingAutoFile(null);
    if (!p) return;

    const url = URL.createObjectURL(p.file);
    emit({ file: p.file, previewUrl: url, meta: p.meta, autoFormat: true });
  }, [emit, pendingAutoFile]);

  const cancelAuto = useCallback(() => {
    setAutoOpen(false);
    setPendingAutoFile(null);
  }, []);

  const startRecording = useCallback(
    async (kind: "audio" | "video") => {
      setLocalError(null);
      setRecordPreviewUrl(null);
      setRecordKind(kind);

      const wantVideo = kind === "video";
      const facingMode = spec.client?.cameraFacingMode ?? "user";

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: wantVideo ? { facingMode } : false,
      });

      recordStreamRef.current = stream;

      const mr = new MediaRecorder(stream);
      mediaRecorderRef.current = mr;
      recordChunksRef.current = [];

      mr.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) recordChunksRef.current.push(e.data);
      };

      mr.onstop = async () => {
        const blob = new Blob(recordChunksRef.current, {
          type: mr.mimeType || (wantVideo ? "video/webm" : "audio/webm"),
        });

        const file = new File([blob], `recording.webm`, { type: blob.type });
        const url = URL.createObjectURL(file);

        setRecordPreviewUrl(url);
        await handleSelected(file, url);
      };

      mr.start();
      setRecording(true);

      const max = spec.client?.maxRecordDurationSec;
      if (max && max > 0) {
        setTimeout(() => {
          try {
            if (mediaRecorderRef.current && mediaRecorderRef.current.state === "recording") {
              mediaRecorderRef.current.stop();
            }
          } catch {}
        }, Math.floor(max * 1000));
      }
    },
    [spec, handleSelected]
  );

  const canPick = spec.client?.allowPick ?? true;
  const canPhoto = spec.client?.allowCapturePhoto ?? true;
  const canRecVideo = spec.client?.allowRecordVideo ?? true;
  const canRecAudio = spec.client?.allowRecordAudio ?? true;

  return (
    <Card className={cn("p-3", className)}>
      <div className="flex flex-wrap gap-2">
        {canPick && (
          <>
            <Input
              id={`media-pick-${id}`}
              ref={pickerRef}
              type="file"
              accept={acceptAttr}
              className="hidden"
              onChange={onPick}
              disabled={disabled || isLoading}
            />
            <Button variant="default" onClick={() => pickerRef.current?.click()} disabled={disabled || isLoading}>
              <Upload className="mr-2 icon-xs" />
              {buttonLabel}
            </Button>
          </>
        )}

        {canPhoto && (
          <>
            <Input
              id={`media-photo-${id}`}
              ref={photoRef}
              type="file"
              accept="image/*"
              capture={spec.client?.cameraFacingMode ?? "user"}
              className="hidden"
              onChange={onPick}
              disabled={disabled || isLoading}
            />
            <Button variant="secondary" onClick={() => photoRef.current?.click()} disabled={disabled || isLoading}>
              <Camera className="mr-2 icon-xs" />
              Take photo
            </Button>
          </>
        )}

        {(canRecVideo || canRecAudio) && (
          <Button variant="secondary" onClick={() => setRecordOpen(true)} disabled={disabled || isLoading}>
            <Video className="mr-2 icon-xs" />
            Record
          </Button>
        )}

        {showInfoToggle ? (
          <Button variant="outline" onClick={() => setShowInfo((v) => !v)} disabled={disabled || isLoading}>
            <Info className="mr-2 icon-xs" />
            {showInfo ? "Hide info" : "Info"}
          </Button>
        ) : null}
      </div>

      {showInfo && showInfoToggle ? <MediaConstraintsHint spec={spec} className="mt-3" /> : null}

      {localError && (
        <Alert variant="destructive" className="mt-3">
          <AlertDescription>{localError.message}</AlertDescription>
        </Alert>
      )}

      {cropSpec && (
        <ImageCropperModal
          isOpen={cropOpen}
          onClose={() => {
            setCropOpen(false);
            setCropSrc(null);
          }}
          imageSrc={cropSrc}
          aspectRatio={cropSpec.aspectRatio}
          shape={"rect"}
          outputWidth={cropSpec.outputWidth}
          outputHeight={cropSpec.outputHeight}
          onCropComplete={onCropComplete}
        />
      )}

      <AutoFormatModal open={autoOpen} onProceed={proceedAuto} onCancel={cancelAuto} />

      <Dialog
        open={recordOpen}
        onOpenChange={(v) => {
          if (!v) {
            stopRecording();
            setRecordOpen(false);
          }
        }}
      >
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>Record</DialogTitle>
            <DialogDescription>Record audio or video.</DialogDescription>
          </DialogHeader>

          <div className="flex flex-wrap gap-2">
            {canRecVideo && (
              <Button
                variant={recordKind === "video" ? "default" : "secondary"}
                onClick={() => setRecordKind("video")}
                disabled={recording}
              >
                <Video className="mr-2 icon-xs" />
                Video
              </Button>
            )}
            {canRecAudio && (
              <Button
                variant={recordKind === "audio" ? "default" : "secondary"}
                onClick={() => setRecordKind("audio")}
                disabled={recording}
              >
                <Mic className="mr-2 icon-xs" />
                Audio
              </Button>
            )}
          </div>

          {recordPreviewUrl && (
            <div className="mt-2">
              {recordKind === "video" ? (
                <video src={recordPreviewUrl} controls className="w-full rounded-md" />
              ) : (
                <audio src={recordPreviewUrl} controls className="w-full" />
              )}
            </div>
          )}

          <DialogFooter className="flex-row justify-between gap-2">
            <Button
              variant="destructive"
              onClick={() => {
                stopRecording();
                setRecordOpen(false);
              }}
              disabled={false}
            >
              <X className="mr-2 icon-xs" />
              Close
            </Button>

            {!recording ? (
              <Button variant="default" onClick={() => startRecording(recordKind)} disabled={disabled || isLoading}>
                {recordKind === "video" ? <Video className="mr-2 icon-xs" /> : <Mic className="mr-2 icon-xs" />}
                Start
              </Button>
            ) : (
              <Button variant="default" onClick={stopRecording}>
                Stop
              </Button>
            )}
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </Card>
  );
}


================================================================================
FILE PATH: packages/file-input/src/components/video-input.tsx
================================================================================
import type { FileInputProps } from "../types";
import { FileInput } from "./file-input";

export function VideoInput(props: Omit<FileInputProps, "acceptTypes">) {
  return <FileInput {...props} acceptTypes={["video"]} />;
}


================================================================================
FILE PATH: packages/file-input/src/index.ts
================================================================================
export * from "./types";

export * from "./components/file-input";
export * from "./components/image-input";
export * from "./components/video-input";
export * from "./components/audio-input";
export * from "./components/media-input";

================================================================================
FILE PATH: packages/file-input/src/lib/image-utils.ts
================================================================================
import type { Area } from "react-easy-crop";

const createImage = (url: string): Promise<HTMLImageElement> =>
  new Promise((resolve, reject) => {
    const image = new Image();
    image.addEventListener("load", () => resolve(image));
    image.addEventListener("error", (error) => reject(error));
    image.setAttribute("crossOrigin", "anonymous");
    image.src = url;
  });

function getRadianAngle(deg: number) {
  return (deg * Math.PI) / 180;
}

function rotateSize(width: number, height: number, rotation: number) {
  const rotRad = getRadianAngle(rotation);
  return {
    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),
    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),
  };
}

export async function getCroppedImg(
  imageSrc: string,
  pixelCrop: Area,
  rotation = 0,
  flip = { horizontal: false, vertical: false },
  outputWidth?: number,
  outputHeight?: number
): Promise<Blob | null> {
  const image = await createImage(imageSrc);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;

  const rotRad = getRadianAngle(rotation);
  const { width: bBoxWidth, height: bBoxHeight } = rotateSize(image.width, image.height, rotation);

  canvas.width = bBoxWidth;
  canvas.height = bBoxHeight;

  ctx.translate(bBoxWidth / 2, bBoxHeight / 2);
  ctx.rotate(rotRad);
  ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);
  ctx.translate(-image.width / 2, -image.height / 2);
  ctx.drawImage(image, 0, 0);

  const croppedCanvas = document.createElement("canvas");
  const croppedCtx = croppedCanvas.getContext("2d");
  if (!croppedCtx) return null;

  croppedCanvas.width = outputWidth || pixelCrop.width;
  croppedCanvas.height = outputHeight || pixelCrop.height;

  croppedCtx.drawImage(
    canvas,
    pixelCrop.x,
    pixelCrop.y,
    pixelCrop.width,
    pixelCrop.height,
    0,
    0,
    croppedCanvas.width,
    croppedCanvas.height
  );

  return new Promise((resolve, reject) => {
    croppedCanvas.toBlob(
      (blob) => (blob ? resolve(blob) : reject(new Error("Canvas to Blob conversion failed"))),
      "image/jpeg",
      0.8
    );
  });
}


================================================================================
FILE PATH: packages/file-input/src/lib/read-media-meta.ts
================================================================================
import { getSimplifiedMediaType } from "@ttt-productions/media-contracts";
import type { MediaKind, VideoOrientation } from "@ttt-productions/media-contracts";

export interface ReadMediaMetaResult {
  kind: MediaKind;
  mime?: string;
  sizeBytes: number;
  width?: number;
  height?: number;
  durationSec?: number;
  orientation?: VideoOrientation;
  aspectRatio?: number;
}

function simplifiedToKind(s: ReturnType<typeof getSimplifiedMediaType>): MediaKind {
  if (s === "image" || s === "video" || s === "audio") return s;
  return "file";
}

function computeOrientation(width?: number, height?: number): VideoOrientation | undefined {
  if (!width || !height) return undefined;
  if (width === height) return "any";
  return height > width ? "vertical" : "horizontal";
}

async function readImage(file: File): Promise<Pick<ReadMediaMetaResult, "width" | "height" | "aspectRatio">> {
  return new Promise((resolve) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      try {
        const width = img.naturalWidth;
        const height = img.naturalHeight;
        resolve({ width, height, aspectRatio: height ? width / height : undefined });
      } finally {
        URL.revokeObjectURL(url);
      }
    };
    img.onerror = () => {
      try {
        URL.revokeObjectURL(url);
      } catch {}
      resolve({});
    };
    img.src = url;
  });
}

async function readAV(
  file: File
): Promise<Pick<ReadMediaMetaResult, "width" | "height" | "durationSec" | "aspectRatio">> {
  return new Promise((resolve) => {
    const isVideo = file.type.startsWith("video/");
    const el = document.createElement(isVideo ? "video" : "audio");
    el.preload = "metadata";

    const url = URL.createObjectURL(file);

    el.onloadedmetadata = () => {
      try {
        const durationSec = Number.isFinite((el as any).duration) ? (el as any).duration : undefined;
        if (isVideo) {
          const v = el as HTMLVideoElement;
          const width = v.videoWidth || undefined;
          const height = v.videoHeight || undefined;
          resolve({ width, height, durationSec, aspectRatio: height ? width! / height : undefined });
        } else {
          resolve({ durationSec });
        }
      } finally {
        try {
          URL.revokeObjectURL(url);
        } catch {}
      }
    };

    el.onerror = () => {
      try {
        URL.revokeObjectURL(url);
      } catch {}
      resolve({});
    };

    el.src = url;
  });
}

export async function readMediaMeta(file: File): Promise<ReadMediaMetaResult> {
  const simplified = getSimplifiedMediaType(file);
  const kind = simplifiedToKind(simplified);

  const base: ReadMediaMetaResult = {
    kind,
    mime: file.type || undefined,
    sizeBytes: file.size,
  };

  if (kind === "image") {
    const img = await readImage(file);
    return {
      ...base,
      ...img,
      orientation: computeOrientation(img.width, img.height),
    };
  }

  if (kind === "video" || kind === "audio") {
    const av = await readAV(file);
    return {
      ...base,
      ...av,
      orientation: kind === "video" ? computeOrientation(av.width, av.height) : undefined,
    };
  }

  return base;
}


================================================================================
FILE PATH: packages/file-input/src/lib/validate-media-duration.ts
================================================================================
export async function validateMediaDuration(file: File, maxDurationSec: number): Promise<boolean> {
    return new Promise((resolve) => {
      const el = document.createElement(file.type.startsWith("video/") ? "video" : "audio");
      el.preload = "metadata";
  
      el.onloadedmetadata = () => {
        URL.revokeObjectURL(el.src);
        resolve(el.duration <= maxDurationSec);
      };
  
      el.onerror = () => {
        // Fail open on client (backend can enforce again).
        try {
          URL.revokeObjectURL(el.src);
        } catch {}
        resolve(true);
      };
  
      el.src = URL.createObjectURL(file);
    });
  }
  

================================================================================
FILE PATH: packages/file-input/src/types.ts
================================================================================
import type {
  FileCategory as ContractsFileCategory,
  MediaKind,
  MediaProcessingSpec,
  SimplifiedMediaType,
  VideoOrientation,
  MediaCropSpec,
} from "@ttt-productions/media-contracts";

/**
 * Back-compat: file-input previously exported FileCategory incorrectly.
 * It now matches contracts FileCategory.
 */
export type FileCategory = ContractsFileCategory;

export interface CropConfig {
  aspectRatio: number;
  aspectRatioDisplay?: string;
  shape: "rect" | "round";
  outputWidth: number;
  outputHeight: number;
}

export interface BackendProcessingConfig {
  image?: {
    maxWidth: number;
    maxHeight: number;
    aspectRatio?: string;
    quality?: number;
  };
  video?: {
    maxWidth: number;
    maxHeight: number;
    aspectRatio?: string;
    codec?: string;
  };
  audio?: {
    bitrate?: string;
    codec?: string;
  };
}

export type FileInputErrorCode =
  | "invalid_type"
  | "too_large"
  | "too_long"
  | "orientation_mismatch"
  | "aspect_ratio_mismatch"
  | "dimensions_mismatch"
  | "read_failed"
  | "crop_failed"
  | "unknown";

export interface FileInputError {
  code: FileInputErrorCode;
  message: string;
  details?: Record<string, unknown>;
}

export interface FileInputChangePayload {
  type: SimplifiedMediaType;
  file?: File;
  blob?: Blob;
  previewUrl?: string;
  error?: FileInputError;
}

export interface FileInputProps {
  /**
   * Allowed simplified categories.
   * If empty -> accept anything.
   */
  acceptTypes: SimplifiedMediaType[];

  /** Max size per type (MB). If missing -> no limit for that type. */
  maxSizeMB: Partial<Record<SimplifiedMediaType, number>>;

  selectedFile?: File | null;

  onChange: (payload: FileInputChangePayload) => void;

  onError?: (error: FileInputError) => void;

  disabled?: boolean;
  isLoading?: boolean;
  buttonLabel?: string;
  className?: string;
  variant?: any;
  size?: any;
  uploadProgress?: number | null;

  videoMaxDurationSec?: number;
  audioMaxDurationSec?: number;

  cropConfig?: CropConfig;

  backendProcessing?: BackendProcessingConfig;

  defaultShowDetails?: boolean;
}

/** Used by MediaInput (spec-driven selection/capture/record). */
export interface SelectedMediaMeta {
  kind: MediaKind;
  mime?: string;
  sizeBytes: number;
  width?: number;
  height?: number;
  durationSec?: number;
  orientation?: VideoOrientation;
  aspectRatio?: number;
}

export interface MediaInputChangePayload {
  spec: MediaProcessingSpec;
  file?: File;
  previewUrl?: string;
  meta?: SelectedMediaMeta;

  /** If true, backend is expected to auto-format to match spec. */
  autoFormat?: boolean;

  /** Client-side crop applied (image only). */
  croppedBlob?: Blob;

  error?: FileInputError;
}

export interface MediaInputProps {
  spec: MediaProcessingSpec;

  /** Optional override for crop UI (if you don't want to use spec.imageCrop). */
  cropOverride?: MediaCropSpec;

  disabled?: boolean;
  isLoading?: boolean;
  className?: string;

  buttonLabel?: string;

  onChange: (payload: MediaInputChangePayload) => void;
}


================================================================================
FILE PATH: packages/file-input/tsconfig.json
================================================================================
{
    "extends": "../../tsconfig.json",
    "compilerOptions": {
      "outDir": "dist",
      "rootDir": "src",
      "noEmitOnError": true
    },
    "include": ["src"]
  }
  

================================================================================
FILE PATH: packages/firebase-helpers/package.json
================================================================================
{
    "name": "@ttt-productions/firebase-helpers",
    "version": "0.2.6",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/firebase-helpers"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        }
    },
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
        "firebase": ">=10.0.0",
        "date-fns": ">=3.0.0"
    },
    "devDependencies": {
        "date-fns": "^4.1.0",
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/firebase-helpers/README.md
================================================================================
# @ttt-productions/firebase-helpers

Generic Firestore utilities (no Firebase initialization, no auth flows, no business logic).

## What’s inside
- Path helpers (collection/doc path builders)
- Timestamp/date helpers (serverTimestamp, conversions)
- Batch helpers (chunking, batched writes)
- Pagination helpers (cursor-based queries)
- Optional React Query-friendly helper (no hard coupling)


================================================================================
FILE PATH: packages/firebase-helpers/src/firestore/batch.ts
================================================================================
import type { Firestore, DocumentData, DocumentReference } from "firebase/firestore";
import { writeBatch } from "firebase/firestore";
import { chunk } from "../utils/chunk";

/**
 * Firestore writeBatch has an operation limit (commonly 500).
 * We keep this generic: caller provides the "apply" function for each item.
 */

export type BatchApplyFn<T> = (batch: ReturnType<typeof writeBatch>, item: T) => void | Promise<void>;

export async function commitInBatches<T>(
  db: Firestore,
  items: T[],
  opts: {
    batchSize?: number;
    apply: BatchApplyFn<T>;
  }
): Promise<{ committedBatches: number; committedOps: number }> {
  const batchSize = opts.batchSize ?? 450; // leave headroom
  const groups = chunk(items, batchSize);

  let committedBatches = 0;
  let committedOps = 0;

  for (const group of groups) {
    const b = writeBatch(db);
    for (const item of group) {
      // allow apply to be sync or async
      await opts.apply(b, item);
    }
    await b.commit();
    committedBatches += 1;
    committedOps += group.length;
  }

  return { committedBatches, committedOps };
}

/**
 * Helper to write many docs to the same collection-like set of refs.
 * You pass refs + data; we batch set() calls.
 */
export async function batchSet<T extends DocumentData>(
  db: Firestore,
  items: Array<{ ref: DocumentReference<T>; data: T; merge?: boolean }>,
  opts?: { batchSize?: number }
) {
  return commitInBatches(db, items, {
    batchSize: opts?.batchSize,
    apply: (b, item) => {
        if (item.merge) {
            b.set(item.ref, item.data, { merge: true });
        } else {
            b.set(item.ref, item.data);
        }
    },
  });
}


================================================================================
FILE PATH: packages/firebase-helpers/src/firestore/pagination.ts
================================================================================
import type {
    DocumentData,
    Query,
    QueryConstraint,
    QueryDocumentSnapshot,
    DocumentSnapshot
  } from "firebase/firestore";
  import {
    getDocs,
    limit,
    orderBy,
    query as fsQuery,
    startAfter
  } from "firebase/firestore";
  
  export type PageResult<T> = {
    items: QueryDocumentSnapshot<T>[];
    nextCursor: DocumentSnapshot<T> | null; // ✅ broadened
    size: number;
  };
  
  export async function fetchPage<T extends DocumentData>(
    baseQuery: Query<T>,
    opts: {
      pageSize: number;
      cursor?: DocumentSnapshot<T> | null; // ✅ broadened
      constraints?: QueryConstraint[];
    }
  ): Promise<PageResult<T>> {
    const constraints: QueryConstraint[] = [
      ...(opts.constraints ?? []),
      ...(opts.cursor ? [startAfter(opts.cursor)] : []),
      limit(opts.pageSize)
    ];
  
    const q = fsQuery(baseQuery, ...constraints);
    const snap = await getDocs(q);
  
    const docs = snap.docs;
    return {
      items: docs,
      nextCursor: docs.length ? docs[docs.length - 1] : null,
      size: docs.length
    };
  }
  
  export async function fetchOrderedPage<T extends DocumentData>(
    baseQuery: Query<T>,
    opts: {
      pageSize: number;
      orderByField: string;
      direction?: "asc" | "desc";
      cursor?: DocumentSnapshot<T> | null; // ✅ broadened
      constraints?: QueryConstraint[];
    }
  ): Promise<PageResult<T>> {
    return fetchPage(baseQuery, {
      pageSize: opts.pageSize,
      cursor: opts.cursor,
      constraints: [orderBy(opts.orderByField, opts.direction ?? "desc"), ...(opts.constraints ?? [])]
    });
  }
  

================================================================================
FILE PATH: packages/firebase-helpers/src/firestore/paths.ts
================================================================================
/**
 * Firestore path utilities.
 * - No app-specific collection names live here.
 * - Use these as building blocks for app-level constants.
 */

const clean = (s: string) => s.replace(/^\/+|\/+$/g, "").trim();

export function joinPath(...parts: Array<string | number | null | undefined>): string {
  const tokens = parts
    .filter((p): p is string | number => p !== null && p !== undefined)
    .map(String)
    .map(clean)
    .filter(Boolean);

  return tokens.join("/");
}

/** Build a collection path from segments */
export function colPath(...segments: Array<string | number>): string {
  return joinPath(...segments);
}

/** Build a document path from segments */
export function docPath(...segments: Array<string | number>): string {
  return joinPath(...segments);
}

/**
 * Create helpers for a "root" namespace.
 * Example:
 *   const paths = makeRootPaths("ttt");
 *   paths.col("users") -> "ttt/users"
 *   paths.doc("users", uid) -> "ttt/users/<uid>"
 */
export function makeRootPaths(root: string) {
  return {
    root: clean(root),
    col: (...segments: Array<string | number>) => colPath(root, ...segments),
    doc: (...segments: Array<string | number>) => docPath(root, ...segments),
  };
}


================================================================================
FILE PATH: packages/firebase-helpers/src/firestore/timestamps.ts
================================================================================
import { Timestamp, serverTimestamp } from "firebase/firestore";
import { format, formatDistanceToNowStrict } from "date-fns";
import { isSerializedTimestamp, hasToDateMethod } from "./types";

/** Firestore server timestamp field value */
export const serverNow = () => serverTimestamp();

/** Convert Firestore Timestamp -> JS Date (safe for undefined/null) */
export function tsToDate(ts?: Timestamp | null): Date | null {
  if (!ts) return null;
  return ts.toDate();
}

/** Convert Date -> Firestore Timestamp */
export function dateToTs(date: Date): Timestamp {
  return Timestamp.fromDate(date);
}

/** Convert ms since epoch -> Firestore Timestamp */
export function msToTs(ms: number): Timestamp {
  return Timestamp.fromMillis(ms);
}

/**
 * Convert any timestamp-like value to milliseconds since epoch.
 * 
 * Handles:
 * - Firestore Timestamp (client SDK)
 * - Objects with toDate() method (duck-typed Timestamps)
 * - Serialized Timestamps from backend ({_seconds, _nanoseconds})
 * - Date objects
 * - ISO date strings
 * - Numbers (returned as-is)
 * 
 * Returns 0 for invalid/null/undefined inputs.
 */
export function toMillis(value: unknown): number {
  if (value === null || value === undefined) return 0;

  // Already a number (milliseconds)
  if (typeof value === "number") return value;

  // Firestore Timestamp with toDate() method (client SDK or duck-typed)
  if (hasToDateMethod(value)) {
    return value.toDate().getTime();
  }

  // Serialized Timestamp from Cloud Functions ({_seconds, _nanoseconds})
  if (isSerializedTimestamp(value)) {
    return value._seconds * 1000 + Math.floor(value._nanoseconds / 1_000_000);
  }

  // Date object
  if (value instanceof Date) {
    return value.getTime();
  }

  // ISO string
  if (typeof value === "string") {
    const date = new Date(value);
    if (!isNaN(date.getTime())) {
      return date.getTime();
    }
  }

  // Unknown format
  if (process.env.NODE_ENV !== "production") {
    console.warn("[firebase-helpers] toMillis: unrecognized format", value);
  }
  return 0;
}

/**
 * Convert any timestamp-like value to a JS Date.
 * 
 * Handles same formats as toMillis().
 * Returns Invalid Date for unrecognized formats.
 */
export function toDate(value: unknown): Date {
  if (value === null || value === undefined) {
    return new Date(NaN);
  }

  // Firestore Timestamp with toDate() method
  if (hasToDateMethod(value)) {
    return value.toDate();
  }

  // Serialized Timestamp from backend
  if (isSerializedTimestamp(value)) {
    return new Date(value._seconds * 1000 + Math.floor(value._nanoseconds / 1_000_000));
  }

  // Date object
  if (value instanceof Date) {
    return value;
  }

  // Number (milliseconds)
  if (typeof value === "number") {
    return new Date(value);
  }

  // ISO string
  if (typeof value === "string") {
    return new Date(value);
  }

  // Unknown format
  if (process.env.NODE_ENV !== "production") {
    console.warn("[firebase-helpers] toDate: unrecognized format", value);
  }
  return new Date(NaN);
}

/**
 * Get current time in milliseconds.
 * Use this instead of Date.now() for consistency.
 */
export function now(): number {
  return Date.now();
}

/**
 * Format a timestamp for display.
 * 
 * @param millis - Milliseconds since epoch (or any TimestampLike value)
 * @param formatType - 'short' for "MMM d, yyyy", 'long' for "MMM d, yyyy 'at' h:mm a"
 * @returns Formatted date string, or 'Invalid Date' for invalid inputs
 */
export function formatDate(
  millis: number | undefined | null,
  formatType: "short" | "long" = "short"
): string {
  if (typeof millis !== "number" || millis === 0) {
    return "Invalid Date";
  }

  try {
    const date = new Date(millis);
    if (isNaN(date.getTime())) {
      return "Invalid Date";
    }

    return formatType === "long"
      ? format(date, "MMM d, yyyy 'at' h:mm a")
      : format(date, "MMM d, yyyy");
  } catch {
    return "Invalid Date";
  }
}

/**
 * Format relative time (e.g., "5 minutes ago", "2 days ago").
 * Re-exported from date-fns for convenience.
 */
export { formatDistanceToNowStrict };


================================================================================
FILE PATH: packages/firebase-helpers/src/firestore/types.ts
================================================================================
import type { DocumentData, DocumentSnapshot, QueryDocumentSnapshot, Timestamp } from "firebase/firestore";

export type DocSnap<T> = DocumentSnapshot<T>;
export type QueryDocSnap<T> = QueryDocumentSnapshot<T>;

export type WithId<T> = T & { id: string };

export function withId<T extends DocumentData>(snap: QueryDocumentSnapshot<T>): WithId<T> {
  return { id: snap.id, ...snap.data() };
}

/**
 * Serialized Firestore Timestamp format.
 * This is what you get when a Timestamp is JSON-serialized from Cloud Functions.
 */
export interface SerializedTimestamp {
  _seconds: number;
  _nanoseconds: number;
}

/**
 * All possible timestamp-like values that can be converted.
 * - Timestamp: Native Firestore Timestamp
 * - Date: JavaScript Date object  
 * - number: Milliseconds since epoch
 * - SerializedTimestamp: JSON-serialized Timestamp from backend
 * - string: ISO date string
 */
export type TimestampLike = Timestamp | Date | number | SerializedTimestamp | string;

/**
 * Type guard: checks if value is a SerializedTimestamp from Cloud Functions
 */
export function isSerializedTimestamp(value: unknown): value is SerializedTimestamp {
  return (
    typeof value === "object" &&
    value !== null &&
    "_seconds" in value &&
    "_nanoseconds" in value &&
    typeof (value as SerializedTimestamp)._seconds === "number" &&
    typeof (value as SerializedTimestamp)._nanoseconds === "number"
  );
}

/**
 * Type guard: checks if value has a toDate() method (duck typing for Timestamp)
 */
export function hasToDateMethod(value: unknown): value is { toDate: () => Date } {
  return (
    typeof value === "object" &&
    value !== null &&
    "toDate" in value &&
    typeof (value as { toDate: unknown }).toDate === "function"
  );
}


================================================================================
FILE PATH: packages/firebase-helpers/src/index.ts
================================================================================
export * from "./firestore/types";
export * from "./firestore/paths";
export * from "./firestore/timestamps";
export * from "./firestore/batch";
export * from "./firestore/pagination";

export * from "./utils/chunk";


================================================================================
FILE PATH: packages/firebase-helpers/src/utils/chunk.ts
================================================================================
export function chunk<T>(items: T[], size: number): T[][] {
    if (!Number.isFinite(size) || size <= 0) throw new Error(`chunk size must be > 0 (got ${size})`);
    const out: T[][] = [];
    for (let i = 0; i < items.length; i += size) out.push(items.slice(i, i + size));
    return out;
  }
  

================================================================================
FILE PATH: packages/firebase-helpers/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "noEmitOnError": true
  },
  "include": ["src"]
}


================================================================================
FILE PATH: packages/media-contracts/package.json
================================================================================
{
    "name": "@ttt-productions/media-contracts",
    "version": "0.2.3",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/media-contracts"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        }
    },
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "devDependencies": {
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/media-contracts/src/helpers.ts
================================================================================
import type { SimplifiedMediaType } from "./types";

export type FileLike = {
  type?: string; // mime
  name?: string; // filename
};

function normalizeMime(mime: string): string {
  return mime.trim().toLowerCase();
}

function extFromName(name?: string): string | undefined {
  if (!name) return undefined;
  const idx = name.lastIndexOf(".");
  if (idx === -1) return undefined;
  return name.slice(idx + 1).trim().toLowerCase() || undefined;
}

function simplifiedFromMime(mime: string): SimplifiedMediaType {
  const m = normalizeMime(mime);

  // common vendor/edge cases
  if (m === "application/octet-stream") return "other";

  if (m.startsWith("image/")) return "image";
  if (m.startsWith("video/")) return "video";
  if (m.startsWith("audio/")) return "audio";

  // PDFs etc treated as "other" for now
  return "other";
}

function simplifiedFromExt(ext?: string): SimplifiedMediaType {
  if (!ext) return "other";

  // images
  if (["jpg", "jpeg", "png", "webp", "gif", "bmp", "tif", "tiff", "avif", "heic", "heif"].includes(ext)) {
    return "image";
  }

  // videos
  if (["mp4", "mov", "m4v", "webm", "mkv", "avi"].includes(ext)) {
    return "video";
  }

  // audio
  if (["mp3", "wav", "m4a", "aac", "flac", "ogg", "opus"].includes(ext)) {
    return "audio";
  }

  return "other";
}

/**
 * Contracts-only type detection.
 * Accepts a mime string OR a File-like object via structural typing.
 * No DOM usage; safe in frontend + functions.
 */
export function getSimplifiedMediaType(input: string | FileLike | null | undefined): SimplifiedMediaType {
  if (!input) return "other";

  if (typeof input === "string") {
    const s = input.trim();
    // if it looks like a mime
    if (s.includes("/")) return simplifiedFromMime(s);
    // otherwise treat as filename/extension-ish
    return simplifiedFromExt(extFromName(s) ?? s.toLowerCase());
  }

  const mime = input.type?.trim();
  if (mime) return simplifiedFromMime(mime);

  const ext = extFromName(input.name);
  return simplifiedFromExt(ext);
}

export function isImageType(input: string | FileLike | null | undefined): boolean {
  return getSimplifiedMediaType(input) === "image";
}

export function isVideoType(input: string | FileLike | null | undefined): boolean {
  return getSimplifiedMediaType(input) === "video";
}

export function isAudioType(input: string | FileLike | null | undefined): boolean {
  return getSimplifiedMediaType(input) === "audio";
}

/** Simple helper for callers that already have mime. */
export function isSupportedMime(mime: string): boolean {
  const t = simplifiedFromMime(mime);
  return t === "image" || t === "video" || t === "audio";
}


================================================================================
FILE PATH: packages/media-contracts/src/index.ts
================================================================================
export * from "./types";
export * from "./helpers";


================================================================================
FILE PATH: packages/media-contracts/src/types.ts
================================================================================
export type SimplifiedMediaType = "image" | "video" | "audio" | "other";

/**
 * Stable, user-facing context category.
 * Feature meaning stays in the app; contracts just carry it.
 */
export type FileCategory =
  | "profile"
  | "post"
  | "message"
  | "comment"
  | "report"
  | "admin"
  | "other";

/**
 * Kinds used by specs and capture UI.
 * "file" means allow any file.
 */
export type MediaKind = "image" | "video" | "audio" | "file";

export type MediaProcessingStatus = "pending" | "processing" | "ready" | "failed" | "rejected";

export type MediaJobStatus = "selecting" | "uploading" | "queued" | "processing" | "ready" | "rejected" | "failed";

export interface MediaJobStatusPayload {
  status: MediaJobStatus;
  progress?: number; // 0..1 (uploading only)
  reasonCode?: string;
  updatedAt?: TimestampLike;
  mediaDocId?: string;
  extra?: Record<string, unknown>;
}

export type MediaErrorCode =
  | "invalid_mime"
  | "too_large"
  | "too_long"
  | "processing_failed"
  | "not_found"
  | "permission_denied"
  | "orientation_mismatch"
  | "aspect_ratio_mismatch"
  | "dimensions_mismatch"
  | "rejected"
  | "unknown";

export type TimestampLike = number | string; // contracts-only (no Firebase Timestamp)

export interface MediaOwnerRef {
  uid: string;
}

export interface MediaThreadRef {
  threadId: string;
}

export type MediaModerationStatus = "passed" | "flagged" | "rejected" | "error";

export interface MediaModerationFinding {
  category?: string;
  label?: string;
  score?: number;
  severity?: string;
  reasons?: string[];
  meta?: Record<string, unknown>;
}

export interface MediaModerationResult {
  status: MediaModerationStatus;
  provider?: string;
  reasons?: string[];
  findings?: MediaModerationFinding[];
  reviewedAt?: TimestampLike;
}


export interface PendingMediaDoc {
  /** Stable id (doc id) */
  id: string;

  owner: MediaOwnerRef;

  /** Optional thread/message context */
  thread?: MediaThreadRef;

  /** Where/why this upload exists (feature-level meaning stays in app) */
  category?: FileCategory;

  /** Client-provided metadata */
  originalName?: string;
  mime?: string;
  sizeBytes?: number;

  /** Simplified bucket used by viewers/validation */
  mediaType: SimplifiedMediaType;

  /** Storage pointers (paths are app-defined) */
  originalPath?: string;
  originalUrl?: string;

  /** Backend processing state */
  status: MediaProcessingStatus;

  /** Processing spec used (if any) */
  spec?: MediaProcessingSpec;

  /** Processing result (if any) */
  result?: MediaProcessingResult;

  /** Error (if failed/rejected) */
  error?: MediaProcessingError;

  createdAt?: TimestampLike;
  updatedAt?: TimestampLike;
}

export interface MediaProcessingError {
  code: MediaErrorCode;
  message: string;
  details?: Record<string, unknown>;
}

export interface MediaAccept {
  /** If omitted/empty, accept anything. */
  mimes?: string[];

  /** If omitted/empty, accept anything. */
  kinds?: MediaKind[];
}

export interface MediaCropSpec {
  /** e.g. 9/16, 4/5, 1 */
  aspectRatio: number;

  /** final output */
  outputWidth: number;
  outputHeight: number;

  format?: "jpeg" | "png" | "webp" | "avif";
  quality?: number; // 1-100

  /** UI hint only */
  aspectRatioDisplay?: string;
}

export type VideoOrientation = "vertical" | "horizontal" | "any";

export interface MediaClientConstraints {
  /** Capture/record hints; UI-only. */
  allowPick?: boolean;
  allowCapturePhoto?: boolean;
  allowRecordVideo?: boolean;
  allowRecordAudio?: boolean;

  /** Prefered camera on mobile. */
  cameraFacingMode?: "user" | "environment";

  /** Record hints. */
  maxRecordDurationSec?: number;
}

export interface ImageVariantSpec {
  /** e.g. "thumb", "sm", "md", "lg", "original" */
  key: string;

  /** Max bounds; backend decides exact output */
  maxWidth?: number;
  maxHeight?: number;

  /** Optional exact crop output */
  crop?: {
    width: number;
    height: number;
    /** center by default */
    gravity?: "center" | "top" | "bottom" | "left" | "right";
  };

  /** Optional format preference */
  format?: "jpeg" | "png" | "webp" | "avif";
  quality?: number; // 1-100
}

export interface MediaProcessingSpec {
  /** Spec version for forwards/backwards compatibility. */
  specVersion?: 1;

  /** What the backend should do. Keep stable + additive. */
  kind: "image" | "video" | "audio" | "generic";

  /** If omitted/empty -> accept anything. */
  accept?: MediaAccept;

  /** If omitted -> no limit. */
  maxBytes?: number;

  /** If omitted -> no limit. Applies to video/audio. */
  maxDurationSec?: number;

  /** Enforce output aspect ratio (uniform UI). */
  requiredAspectRatio?: number;

  /** Enforce output dimensions (uniform UI). */
  requiredWidth?: number;
  requiredHeight?: number;

  /** Enforce source orientation (video). */
  videoOrientation?: VideoOrientation;

  /** If source doesn't match constraints, allow backend to auto-format. */
  allowAutoFormat?: boolean;

  /** Optional image crop/resize on client + backend. */
  imageCrop?: MediaCropSpec;

  /** UI hints for capture/record */
  client?: MediaClientConstraints;

  /** Image pipeline (sharp etc) */
  image?: {
    variants: ImageVariantSpec[];
    stripMetadata?: boolean;
  };

  video?: {
    maxDurationSec?: number;
  };

  audio?: {
    maxDurationSec?: number;
  };
}

export interface MediaOutput {
  key: string;
  url: string;
  path?: string;

  mime?: string;
  sizeBytes?: number;

  width?: number;
  height?: number;

  durationSec?: number;

  extra?: Record<string, unknown>;
}

export interface MediaProcessingResult {
  ok: boolean;

  mediaType: SimplifiedMediaType;

  outputs?: MediaOutput[];

  meta?: {
    mime?: string;
    sizeBytes?: number;
    width?: number;
    height?: number;
    durationSec?: number;
  };

  warnings?: string[];

  error?: MediaProcessingError;

  moderation?: MediaModerationResult;
}

export interface ReportPayload {
  reporter: MediaOwnerRef;

  target: {
    mediaId: string;
    owner?: MediaOwnerRef;
    category?: FileCategory;
  };

  reason: string;
  details?: string;

  createdAt?: TimestampLike;

  extra?: Record<string, unknown>;
}


================================================================================
FILE PATH: packages/media-contracts/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}


================================================================================
FILE PATH: packages/media-processing-core/package.json
================================================================================
{
  "name": "@ttt-productions/media-processing-core",
  "version": "0.0.0",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ttt-productions/ttt-packages.git",
    "directory": "packages/media-processing-core"
  },
  "type": "module",
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "sideEffects": false,
  "files": ["dist"],
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "clean": "rm -rf dist *.tsbuildinfo",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "npm run clean && npm run build"
  },
  "peerDependencies": {
    "@ttt-productions/media-contracts": "*"
  },
  "dependencies": {
    "sharp": "^0.34.1",
    "@ttt-productions/media-contracts": "file:../media-contracts"
  },
  "devDependencies": {
    "@types/node": "^22.10.0",
    "typescript": "^5.8.3"
  },
  "author": "DJ (TTT Productions)",
  "license": "MIT"
}


================================================================================
FILE PATH: packages/media-processing-core/src/audio/audio-processor.ts
================================================================================
import type { MediaOutput, MediaProcessingResult, MediaProcessingSpec } from "@ttt-productions/media-contracts";
import { mkdir, stat } from "node:fs/promises";
import path from "node:path";
import { runCmd } from "../video/ffmpeg";
import { probeAudio } from "./probe";

function matchMime(accepted: string, actual: string): boolean {
  const a = accepted.trim().toLowerCase();
  const m = actual.trim().toLowerCase();
  if (!a) return true;
  if (a === "*/*") return true;
  if (a.endsWith("/*")) return m.startsWith(a.slice(0, -1));
  return a === m;
}

function acceptAllowsAudio(spec: MediaProcessingSpec): boolean {
  const kinds = spec.accept?.kinds?.filter(Boolean) ?? [];
  return kinds.length === 0 ? true : kinds.includes("audio");
}

function acceptAllowsMime(spec: MediaProcessingSpec, actualMime?: string): boolean {
  const mimes = spec.accept?.mimes?.filter(Boolean) ?? [];
  if (mimes.length === 0) return true; // empty => accept anything
  if (!actualMime) return false;
  return mimes.some((a) => matchMime(a, actualMime));
}

function outputPathFor(base: string, key: string, ext: string): string {
  return `${base}_${key}.${ext}`;
}

export async function processAudio(
  spec: MediaProcessingSpec,
  ctx: {
    inputPath: string;
    outputBasePath: string;
    inputMime?: string;
  }
): Promise<MediaProcessingResult> {
  try {
    if (!acceptAllowsAudio(spec)) {
      return {
        ok: false,
        mediaType: "audio",
        error: { code: "invalid_mime", message: "Spec does not allow audio uploads.", details: { accept: spec.accept } },
      };
    }

    if (!acceptAllowsMime(spec, ctx.inputMime)) {
      return {
        ok: false,
        mediaType: "audio",
        error: { code: "invalid_mime", message: "Audio mime type is not allowed.", details: { inputMime: ctx.inputMime, accept: spec.accept } },
      };
    }

    const outDir = path.dirname(ctx.outputBasePath);
    await mkdir(outDir, { recursive: true });

    const probe = await probeAudio(ctx.inputPath);

    const maxDur = spec.maxDurationSec ?? spec.audio?.maxDurationSec;
    if (maxDur && probe.durationSec && probe.durationSec > maxDur) {
      return {
        ok: false,
        mediaType: "audio",
        error: {
          code: "too_long",
          message: "Audio is too long.",
          details: { durationSec: probe.durationSec, maxDurationSec: maxDur },
        },
      };
    }

    // Normalize to AAC in m4a (small + widely supported)
    const outPath = outputPathFor(ctx.outputBasePath, "main", "m4a");

    const args = [
      "-y",
      "-i",
      ctx.inputPath,
      "-vn",
      "-c:a",
      "aac",
      "-b:a",
      "128k",
      outPath,
    ];

    const r = await runCmd("ffmpeg", args);
    if (r.code !== 0) {
      return {
        ok: false,
        mediaType: "audio",
        error: {
          code: "processing_failed",
          message: "ffmpeg audio transcode failed.",
          details: { stderr: r.stderr?.slice(0, 2000) },
        },
      };
    }

    const s = await stat(outPath);

    const outputs: MediaOutput[] = [
      {
        key: "main",
        url: `file://${outPath}`,
        path: outPath,
        mime: "audio/mp4",
        sizeBytes: s.size,
        durationSec: probe.durationSec,
      },
    ];

    return {
      ok: true,
      mediaType: "audio",
      outputs,
      meta: {
        mime: ctx.inputMime,
        durationSec: probe.durationSec,
      },
    };
  } catch (e: any) {
    return {
      ok: false,
      mediaType: "audio",
      error: {
        code: "processing_failed",
        message: e?.message ? String(e.message) : "Audio processing failed",
        details: { name: e?.name },
      },
    };
  }
}


================================================================================
FILE PATH: packages/media-processing-core/src/audio/index.ts
================================================================================
export * from "./audio-processor";
export * from "./probe";


================================================================================
FILE PATH: packages/media-processing-core/src/audio/probe.ts
================================================================================
import { runCmd } from "../video/ffmpeg";

export interface AudioProbe {
  durationSec?: number;
}

export async function probeAudio(inputPath: string): Promise<AudioProbe> {
  const args = ["-v", "error", "-print_format", "json", "-show_format", inputPath];

  const r = await runCmd("ffprobe", args);

  if (r.code !== 0) {
    throw new Error(`ffprobe failed (${r.code}): ${r.stderr || r.stdout}`);
  }

  const json = JSON.parse(r.stdout || "{}");
  const format: any = json.format ?? {};
  const durationStr = format.duration;
  const durationSec = durationStr ? Number(durationStr) : undefined;

  return { durationSec: Number.isFinite(durationSec) ? durationSec : undefined };
}


================================================================================
FILE PATH: packages/media-processing-core/src/firebase/firestore.ts
================================================================================
import type { MediaProcessingResult } from "@ttt-productions/media-contracts";

export function mapResultForFirestore(
  result: MediaProcessingResult
) {
  return {
    status: result.ok ? "ready" : "failed",
    result: result.ok ? result : null,
    error: result.ok ? null : result.error ?? null,
    updatedAt: Date.now()
  };
}


================================================================================
FILE PATH: packages/media-processing-core/src/firebase/storage.ts
================================================================================
// functions-only helpers for firebase-admin storage
// kept minimal so handlers stay thin

export function buildStoragePath(
    basePath: string,
    filename: string
  ): string {
    return `${basePath}/${filename}`.replace(/\/+/g, "/");
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/image/formats.ts
================================================================================
// shared image format / quality presets


================================================================================
FILE PATH: packages/media-processing-core/src/image/image-processor.ts
================================================================================
import type { MediaOutput, MediaProcessingResult, MediaProcessingSpec } from "@ttt-productions/media-contracts";
import sharp from "sharp";
import { mkdir } from "node:fs/promises";
import path from "node:path";

type Gravity = "center" | "top" | "bottom" | "left" | "right";

function matchMime(accepted: string, actual: string): boolean {
  const a = accepted.trim().toLowerCase();
  const m = actual.trim().toLowerCase();
  if (!a) return true;
  if (a === "*/*") return true;
  if (a.endsWith("/*")) return m.startsWith(a.slice(0, -1));
  return a === m;
}

function acceptAllowsImage(spec: MediaProcessingSpec): boolean {
  const kinds = spec.accept?.kinds?.filter(Boolean) ?? [];
  return kinds.length === 0 ? true : kinds.includes("image");
}

function acceptAllowsMime(spec: MediaProcessingSpec, actualMime?: string): boolean {
  const mimes = spec.accept?.mimes?.filter(Boolean) ?? [];
  if (mimes.length === 0) return true; // empty => accept anything
  if (!actualMime) return false;
  return mimes.some((a) => matchMime(a, actualMime));
}


function toSharpPosition(g?: Gravity): sharp.Gravity {
  switch (g) {
    case "top":
      return "north";
    case "bottom":
      return "south";
    case "left":
      return "west";
    case "right":
      return "east";
    case "center":
    default:
      return "centre";
  }
}

function pickFormat(fmt?: string): { ext: string; format: "jpeg" | "png" | "webp" | "avif" } {
  switch ((fmt ?? "jpeg").toLowerCase()) {
    case "png":
      return { ext: "png", format: "png" };
    case "webp":
      return { ext: "webp", format: "webp" };
    case "avif":
      return { ext: "avif", format: "avif" };
    case "jpg":
    case "jpeg":
    default:
      return { ext: "jpg", format: "jpeg" };
  }
}

function outputPathFor(base: string, key: string, ext: string): string {
  return `${base}_${key}.${ext}`;
}

function mimeForImageFormat(fmt?: string): string | undefined {
  if (!fmt) return undefined;
  const f = fmt.toLowerCase();
  if (f === "jpg") return "image/jpeg";
  if (f === "jpeg") return "image/jpeg";
  if (f === "png") return "image/png";
  if (f === "webp") return "image/webp";
  if (f === "avif") return "image/avif";
  return `image/${f}`;
}

function aspect(width?: number, height?: number): number | undefined {
  if (!width || !height) return undefined;
  return width / height;
}

function aspectClose(a: number, b: number, tolerance = 0.02): boolean {
  return Math.abs(a - b) <= tolerance;
}

/**
 * Build a "normalized base" pipeline that enforces spec-level uniformity:
 * - if imageCrop exists -> always crop to outputWidth/outputHeight
 * - else if requiredWidth/requiredHeight exist -> crop/resize to those
 * - else if requiredAspectRatio exists -> center-crop to that aspect (no scaling unless needed later)
 *
 * If the source violates constraints and we cannot/should not auto-fix, returns a rejection error.
 */
async function buildBase(
  spec: MediaProcessingSpec,
  inputPath: string
): Promise<
  | { ok: true; base: sharp.Sharp; inputMeta: sharp.Metadata }
  | { ok: false; error: MediaProcessingResult["error"] }
> {
  const input = sharp(inputPath, { failOn: "none" });
  const meta = await input.metadata();

  if (!acceptAllowsImage(spec)) {
    return {
      ok: false,
      error: {
        code: "invalid_mime",
        message: "Spec does not allow image uploads.",
        details: { accept: spec.accept },
      },
    };
  }
  
  const detectedMime = mimeForImageFormat(meta.format);
  if (!acceptAllowsMime(spec, detectedMime)) {
    return {
      ok: false,
      error: {
        code: "invalid_mime",
        message: "Image mime type is not allowed.",
        details: { detectedMime, accept: spec.accept },
      },
    };
  }

  const w = meta.width ?? undefined;
  const h = meta.height ?? undefined;

  if (!w || !h) {
    // Can't validate/crop reliably without dimensions.
    // We'll still proceed unless strict dims/aspect are required without crop/auto.
    if (spec.requiredWidth || spec.requiredHeight || spec.requiredAspectRatio) {
      if (!spec.allowAutoFormat && !spec.imageCrop) {
        return {
          ok: false,
          error: {
            code: "dimensions_mismatch",
            message: "Unable to read image dimensions for validation.",
            details: { width: w, height: h },
          },
        };
      }
    }
  }

  // Start from raw input each time; callers can clone as needed.
  let base = sharp(inputPath, { failOn: "none" });

  // Keep metadata only if explicitly requested.
  if (spec.image?.stripMetadata === false) {
    base = base.withMetadata({ orientation: meta.orientation });
  }

  // 1) Explicit crop spec (most strict)
  const crop = spec.imageCrop;
  if (crop) {
    base = base.resize(crop.outputWidth, crop.outputHeight, {
      fit: "cover",
      position: "centre",
      withoutEnlargement: true,
    });
    return { ok: true, base, inputMeta: meta };
  }

  // 2) Exact required size -> auto crop/resize only if allowAutoFormat OR the request is inherently "uniform"
  const reqW = spec.requiredWidth;
  const reqH = spec.requiredHeight;
  if (reqW && reqH) {
    const canFix = spec.allowAutoFormat === true;
    // If not allowed to auto-fix, require exact match
    if (!canFix && w && h && (w !== reqW || h !== reqH)) {
      return {
        ok: false,
        error: {
          code: "dimensions_mismatch",
          message: "Image dimensions do not match the required format.",
          details: { requiredWidth: reqW, requiredHeight: reqH, width: w, height: h },
        },
      };
    }

    // Auto-fix path (or exact already): enforce normalized base
    base = base.resize(reqW, reqH, {
      fit: "cover",
      position: "centre",
      withoutEnlargement: true,
    });

    return { ok: true, base, inputMeta: meta };
  }

  // 3) Aspect ratio requirement (no exact size)
  const reqAspect = spec.requiredAspectRatio;
  if (reqAspect && w && h) {
    const a = aspect(w, h);
    if (a && !aspectClose(a, reqAspect)) {
      if (!spec.allowAutoFormat) {
        return {
          ok: false,
          error: {
            code: "aspect_ratio_mismatch",
            message: "Image aspect ratio does not match the required format.",
            details: { requiredAspectRatio: reqAspect, aspectRatio: a, width: w, height: h },
          },
        };
      }

      // Auto center-crop to required aspect ratio (no forced scale yet)
      // Compute a crop box that matches reqAspect and fits within original dimensions.
      let cropW = w;
      let cropH = h;

      if (a > reqAspect) {
        // too wide -> reduce width
        cropW = Math.max(1, Math.floor(h * reqAspect));
      } else {
        // too tall -> reduce height
        cropH = Math.max(1, Math.floor(w / reqAspect));
      }

      const left = Math.max(0, Math.floor((w - cropW) / 2));
      const top = Math.max(0, Math.floor((h - cropH) / 2));

      base = base.extract({ left, top, width: cropW, height: cropH });
    }
  }

  return { ok: true, base, inputMeta: meta };
}

export async function processImage(
  spec: MediaProcessingSpec,
  ctx: {
    inputPath: string;
    outputBasePath: string;
  }
): Promise<MediaProcessingResult> {
  try {
    const variants =
      spec.image?.variants?.length ? spec.image.variants : [{ key: "original" as const }];

    const outDir = path.dirname(ctx.outputBasePath);
    await mkdir(outDir, { recursive: true });

    const baseRes = await buildBase(spec, ctx.inputPath);
    if (!baseRes.ok) {
      return { ok: false, mediaType: "image", error: baseRes.error };
    }

    const { base, inputMeta } = baseRes;

    const outputs: MediaOutput[] = [];

    for (const v of variants) {
      const { ext, format } = pickFormat(v.format);
      const outPath = outputPathFor(ctx.outputBasePath, v.key, ext);

      // Clone from normalized base so each variant is consistent
      let p = base.clone();

      if (v.crop) {
        p = p.resize(v.crop.width, v.crop.height, {
          fit: "cover",
          position: toSharpPosition((v.crop.gravity as Gravity) ?? "center"),
          withoutEnlargement: true,
        });
      } else if (v.maxWidth || v.maxHeight) {
        p = p.resize(v.maxWidth ?? null, v.maxHeight ?? null, {
          fit: "inside",
          withoutEnlargement: true,
        });
      }

      const q = typeof v.quality === "number" ? v.quality : undefined;

      switch (format) {
        case "png":
          p = p.png();
          break;
        case "webp":
          p = p.webp(q ? { quality: q } : undefined);
          break;
        case "avif":
          p = p.avif(q ? { quality: q } : undefined);
          break;
        case "jpeg":
        default:
          p = p.jpeg(q ? { quality: q } : undefined);
          break;
      }

      const info = await p.toFile(outPath);

      outputs.push({
        key: v.key,
        url: `file://${outPath}`,
        path: outPath,
        mime: mimeForImageFormat(info.format),
        sizeBytes: info.size,
        width: info.width,
        height: info.height,
      });
    }

    return {
      ok: true,
      mediaType: "image",
      outputs,
      meta: {
        mime: mimeForImageFormat(inputMeta.format),
        width: inputMeta.width,
        height: inputMeta.height,
      },
    };
  } catch (e: any) {
    return {
      ok: false,
      mediaType: "image",
      error: {
        code: "processing_failed",
        message: e?.message ? String(e.message) : "Image processing failed",
        details: { name: e?.name },
      },
    };
  }
}


================================================================================
FILE PATH: packages/media-processing-core/src/image/index.ts
================================================================================
export * from "./image-processor";


================================================================================
FILE PATH: packages/media-processing-core/src/image/resize.ts
================================================================================
// sharp resize helpers extracted from existing image-processor
// intentionally empty until extraction step


================================================================================
FILE PATH: packages/media-processing-core/src/index.ts
================================================================================
export * from "./image";
export * from "./image/image-processor";

export * from "./video";
export * from "./video/video-processor";

export * from "./process-media";
export * from "./workspace/temp";

export * from "./audio";
export * from "./audio/audio-processor";

export * from "./io/types";
export * from "./run-pipeline";

export * from "./io/fs";

export * from "./moderation/types";

================================================================================
FILE PATH: packages/media-processing-core/src/io/fs.ts
================================================================================
import type { MediaIO } from "./types";
import { copyFile, mkdir } from "node:fs/promises";
import path from "node:path";

export function createFsIO(args: {
  inputPath: string;
  inputMime?: string;
  outputDir: string;
}): MediaIO {
  return {
    input: {
      mime: args.inputMime,
      async readToFile(localPath) {
        await copyFile(args.inputPath, localPath);
      },
    },
    output: {
      async writeFromFile(localPath, key) {
        await mkdir(args.outputDir, { recursive: true });
        const ext = path.extname(localPath);
        const out = path.join(args.outputDir, `${key}${ext}`);
        await copyFile(localPath, out);
        return { path: out, url: `file://${out}` };
      },
    },
  };
}


================================================================================
FILE PATH: packages/media-processing-core/src/io/types.ts
================================================================================
export interface MediaInputSource {
    /** Copy source media into localPath */
    readToFile(localPath: string): Promise<void>;
  
    /** Optional mime hint */
    mime?: string;
  }
  
  export interface MediaOutputTarget {
    /** Persist a processed file from localPath */
    writeFromFile(localPath: string, outputKey: string): Promise<{
      url?: string;
      path?: string;
    }>;
  }
  
  export interface MediaIO {
    input: MediaInputSource;
    output: MediaOutputTarget;
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/moderation/types.ts
================================================================================
import type { MediaModerationResult, MediaProcessingSpec } from "@ttt-productions/media-contracts";

export interface ModerationInput {
  spec: MediaProcessingSpec;
  kind: "image" | "video" | "audio" | "generic";
  localPath: string;
  mime?: string;
}

export interface ModerationOutput {
  spec: MediaProcessingSpec;
  kind: "image" | "video" | "audio" | "generic";
  outputs: Array<{
    key: string;
    localPath: string;
    mime?: string;
  }>;
}

export interface ModerationAdapter {
  provider: string;

  /** Run on the ORIGINAL uploaded file before processing. */
  moderateInput?: (input: ModerationInput) => Promise<MediaModerationResult | null | undefined>;

  /** Run on PROCESSED outputs after processing. */
  moderateOutput?: (output: ModerationOutput) => Promise<MediaModerationResult | null | undefined>;
}


================================================================================
FILE PATH: packages/media-processing-core/src/processing/errors.ts
================================================================================
export function processingError(
    code: string,
    message: string,
    details?: Record<string, unknown>
  ) {
    return {
      code,
      message,
      details
    };
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/processing/process-media.ts
================================================================================
import type {
    MediaProcessingSpec,
    MediaProcessingResult
  } from "@ttt-productions/media-contracts";
  
  import { processImage } from "../image/image-processor";
  import { processVideo } from "../video/video-processor";
  import { processAudio } from "../audio/audio-processor";
  
  export async function processMedia(
    spec: MediaProcessingSpec,
    ctx: {
      inputPath: string;
      outputBasePath: string;
    }
  ): Promise<MediaProcessingResult> {
    switch (spec.kind) {
      case "image":
        return processImage(spec, ctx);
  
      case "video":
        return processVideo(spec, ctx);
  
      case "audio":
        return processAudio(spec, ctx);
  
      default:
        return {
          ok: false,
          mediaType: "other",
          error: {
            code: "unknown",
            message: "Unsupported media type"
          }
        };
    }
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/processing/result.ts
================================================================================
import type { MediaProcessingResult } from "@ttt-productions/media-contracts";

export function success(
  result: Omit<MediaProcessingResult, "ok">
): MediaProcessingResult {
  return { ok: true, ...result };
}

export function failure(
  error: MediaProcessingResult["error"]
): MediaProcessingResult {
  return {
    ok: false,
    mediaType: "other",
    error
  };
}


================================================================================
FILE PATH: packages/media-processing-core/src/process-media.ts
================================================================================
import type { MediaProcessingResult, MediaProcessingSpec } from "@ttt-productions/media-contracts";
import { processImage } from "./image/image-processor";
import { processVideo } from "./video/video-processor";
import { processAudio } from "./audio/audio-processor";

export interface ProcessMediaContext {
  inputPath: string;
  outputBasePath: string;

  /** optional mime hint from caller */
  inputMime?: string;
}

export async function processMedia(
  spec: MediaProcessingSpec,
  ctx: ProcessMediaContext
): Promise<MediaProcessingResult> {
  switch (spec.kind) {
    case "image":
      return processImage(spec, ctx);

    case "video":
      return processVideo(spec, ctx);

    case "audio":
      return processAudio(spec, ctx);

    case "generic":
    default:
      return {
        ok: false,
        mediaType: "other",
        error: { code: "processing_failed", message: "Generic processing not implemented yet." },
      };
  }
}


================================================================================
FILE PATH: packages/media-processing-core/src/run-pipeline.ts
================================================================================
import type { MediaProcessingResult, MediaProcessingSpec, MediaModerationResult } from "@ttt-productions/media-contracts";
import { createTempWorkspace } from "./workspace/temp";
import { processMedia } from "./process-media";
import type { MediaIO } from "./io/types";
import type { ModerationAdapter } from "./moderation/types";
import path from "node:path";

export interface RunPipelineArgs {
  spec: MediaProcessingSpec;
  io: MediaIO;

  /** base filename without extension */
  outputBaseName?: string;

  /** optional moderation hook */
  moderation?: ModerationAdapter;
}

function mediaTypeFromSpecKind(kind: MediaProcessingSpec["kind"]): "image" | "video" | "audio" | "other" {
  if (kind === "image") return "image";
  if (kind === "video") return "video";
  if (kind === "audio") return "audio";
  return "other";
}

function attachProvider(m: MediaModerationResult | null | undefined, provider?: string): MediaModerationResult | null | undefined {
  if (!m) return m;
  return { ...m, provider: m.provider ?? provider, reviewedAt: m.reviewedAt ?? Date.now() };
}

export async function runMediaPipeline(args: RunPipelineArgs): Promise<MediaProcessingResult> {
  const { spec, io, outputBaseName = "media", moderation } = args;

  const ws = await createTempWorkspace("ttt-media-");

  try {
    const inputPath = path.join(ws.dir, "input");
    const outputBasePath = path.join(ws.dir, outputBaseName);

    await io.input.readToFile(inputPath);

    // PRE moderation (original)
    if (moderation?.moderateInput) {
      const m0 = attachProvider(
        await moderation.moderateInput({
          spec,
          kind: spec.kind,
          localPath: inputPath,
          mime: io.input.mime,
        }),
        moderation.provider
      );

      if (m0?.status === "rejected") {
        return {
          ok: false,
          mediaType: mediaTypeFromSpecKind(spec.kind),
          moderation: m0,
          error: {
            code: "rejected",
            message: "Rejected by moderation.",
            details: { provider: m0.provider, reasons: m0.reasons, findings: m0.findings },
          },
        };
      }

      // if flagged/passed, carry it forward (merged later if output moderation exists)
      // we store it on result after processing
      // (no-op here)
    }

    const result = await processMedia(spec, {
      inputPath,
      outputBasePath,
      inputMime: io.input.mime,
    });

    // If processing failed, still return (but attach pre-moderation if we have it)
    if (!result.ok || !result.outputs?.length) {
      return result;
    }

    // Persist outputs
    for (const out of result.outputs) {
      if (!out.path) continue;
      const persisted = await io.output.writeFromFile(out.path, out.key);
      if (persisted.url) out.url = persisted.url;
      if (persisted.path) out.path = persisted.path;
    }

    // POST moderation (processed outputs)
    let mOut: MediaModerationResult | null | undefined;
    if (moderation?.moderateOutput) {
      mOut = attachProvider(
        await moderation.moderateOutput({
          spec,
          kind: spec.kind,
          outputs: (result.outputs ?? [])
            .filter((o) => !!o.path)
            .map((o) => ({ key: o.key, localPath: o.path!, mime: o.mime })),
        }),
        moderation.provider
      );

      if (mOut?.status === "rejected") {
        return {
          ok: false,
          mediaType: result.mediaType,
          moderation: mOut,
          error: {
            code: "rejected",
            message: "Rejected by moderation.",
            details: { provider: mOut.provider, reasons: mOut.reasons, findings: mOut.findings },
          },
        };
      }
    }

    // Attach moderation info if any
    if (mOut) {
      result.moderation = mOut;
    }

    return result;
  } finally {
    await ws.cleanup();
  }
}


================================================================================
FILE PATH: packages/media-processing-core/src/types.ts
================================================================================
import type {
    MediaProcessingSpec,
    MediaProcessingResult
  } from "@ttt-productions/media-contracts";
  
  export interface ProcessMediaContext {
    inputPath: string;
    outputBasePath: string;
  }
  
  export type ProcessMediaFn = (
    spec: MediaProcessingSpec,
    ctx: ProcessMediaContext
  ) => Promise<MediaProcessingResult>;
  

================================================================================
FILE PATH: packages/media-processing-core/src/utils/log.ts
================================================================================
export function log(...args: unknown[]) {
    console.log("[media-processing]", ...args);
  }
  
  export function warn(...args: unknown[]) {
    console.warn("[media-processing]", ...args);
  }
  
  export function error(...args: unknown[]) {
    console.error("[media-processing]", ...args);
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/utils/paths.ts
================================================================================
export function joinPath(...parts: string[]) {
    return parts
      .filter(Boolean)
      .join("/")
      .replace(/\/+/g, "/");
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/validation/validate-duration.ts
================================================================================
export function validateDuration(
    durationSec: number,
    maxDurationSec: number
  ): boolean {
    return durationSec <= maxDurationSec;
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/validation/validate-mime.ts
================================================================================
export function validateMime(
    mime: string,
    allowed: string[]
  ): boolean {
    return allowed.includes(mime);
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/validation/validate-size.ts
================================================================================
export function validateSize(
    bytes: number,
    maxBytes: number
  ): boolean {
    return bytes <= maxBytes;
  }
  

================================================================================
FILE PATH: packages/media-processing-core/src/video/ffmpeg.ts
================================================================================
import { spawn } from "node:child_process";

export interface RunCmdResult {
  code: number;
  stdout: string;
  stderr: string;
}

export function runCmd(cmd: string, args: string[], opts?: { cwd?: string }): Promise<RunCmdResult> {
  return new Promise((resolve, reject) => {
    const p = spawn(cmd, args, { cwd: opts?.cwd, stdio: ["ignore", "pipe", "pipe"] });

    let stdout = "";
    let stderr = "";

    p.stdout.on("data", (d) => (stdout += String(d)));
    p.stderr.on("data", (d) => (stderr += String(d)));

    p.on("error", reject);
    p.on("close", (code) => resolve({ code: code ?? 0, stdout, stderr }));
  });
}


================================================================================
FILE PATH: packages/media-processing-core/src/video/index.ts
================================================================================
export * from "./video-processor";
export * from "./probe";
export * from "./ffmpeg";


================================================================================
FILE PATH: packages/media-processing-core/src/video/probe.ts
================================================================================
import { runCmd } from "./ffmpeg";

export interface VideoProbe {
  durationSec?: number;
  width?: number;
  height?: number;
  hasAudio?: boolean;
}

export async function probeVideo(inputPath: string): Promise<VideoProbe> {
  // ffprobe must exist in runtime environment
  const args = [
    "-v",
    "error",
    "-print_format",
    "json",
    "-show_streams",
    "-show_format",
    inputPath,
  ];

  const r = await runCmd("ffprobe", args);

  if (r.code !== 0) {
    throw new Error(`ffprobe failed (${r.code}): ${r.stderr || r.stdout}`);
  }

  const json = JSON.parse(r.stdout || "{}");

  const streams: any[] = Array.isArray(json.streams) ? json.streams : [];
  const format: any = json.format ?? {};

  const v = streams.find((s) => s.codec_type === "video");
  const a = streams.find((s) => s.codec_type === "audio");

  const durationStr = format.duration ?? v?.duration ?? a?.duration;
  const durationSec = durationStr ? Number(durationStr) : undefined;

  const width = v?.width ? Number(v.width) : undefined;
  const height = v?.height ? Number(v.height) : undefined;

  return {
    durationSec: Number.isFinite(durationSec) ? durationSec : undefined,
    width,
    height,
    hasAudio: !!a,
  };
}


================================================================================
FILE PATH: packages/media-processing-core/src/video/video-processor.ts
================================================================================
import type { MediaOutput, MediaProcessingResult, MediaProcessingSpec, VideoOrientation } from "@ttt-productions/media-contracts";
import { mkdir, stat } from "node:fs/promises";
import path from "node:path";
import { runCmd } from "./ffmpeg";
import { probeVideo } from "./probe";

function matchMime(accepted: string, actual: string): boolean {
  const a = accepted.trim().toLowerCase();
  const m = actual.trim().toLowerCase();
  if (!a) return true;
  if (a === "*/*") return true;
  if (a.endsWith("/*")) return m.startsWith(a.slice(0, -1));
  return a === m;
}

function acceptAllowsVideo(spec: MediaProcessingSpec): boolean {
  const kinds = spec.accept?.kinds?.filter(Boolean) ?? [];
  return kinds.length === 0 ? true : kinds.includes("video");
}

function acceptAllowsMime(spec: MediaProcessingSpec, actualMime?: string): boolean {
  const mimes = spec.accept?.mimes?.filter(Boolean) ?? [];
  if (mimes.length === 0) return true; // empty => accept anything
  if (!actualMime) return false;
  return mimes.some((a) => matchMime(a, actualMime));
}

function aspect(width?: number, height?: number): number | undefined {
  if (!width || !height) return undefined;
  return width / height;
}

function aspectClose(a: number, b: number, tolerance = 0.02): boolean {
  return Math.abs(a - b) <= tolerance;
}

function orientationOf(width?: number, height?: number): VideoOrientation | undefined {
  if (!width || !height) return undefined;
  if (width === height) return "any";
  return height > width ? "vertical" : "horizontal";
}

function orientationOk(required: VideoOrientation | undefined, actual: VideoOrientation | undefined): boolean {
  if (!required || required === "any") return true;
  if (!actual || actual === "any") return true; // treat square/unknown as ok
  return required === actual;
}

function outputPathFor(base: string, key: string, ext: string): string {
  return `${base}_${key}.${ext}`;
}

function mimeFromExt(ext: string): string | undefined {
  if (ext === "mp4") return "video/mp4";
  if (ext === "webm") return "video/webm";
  return undefined;
}

export async function processVideo(
  spec: MediaProcessingSpec,
  ctx: {
    inputPath: string;
    outputBasePath: string;
    inputMime?: string;
  }
): Promise<MediaProcessingResult> {
  try {
    if (!acceptAllowsVideo(spec)) {
      return {
        ok: false,
        mediaType: "video",
        error: { code: "invalid_mime", message: "Spec does not allow video uploads.", details: { accept: spec.accept } },
      };
    }

    if (!acceptAllowsMime(spec, ctx.inputMime)) {
      return {
        ok: false,
        mediaType: "video",
        error: { code: "invalid_mime", message: "Video mime type is not allowed.", details: { inputMime: ctx.inputMime, accept: spec.accept } },
      };
    }

    const outDir = path.dirname(ctx.outputBasePath);
    await mkdir(outDir, { recursive: true });

    const probe = await probeVideo(ctx.inputPath);

    // duration enforcement
    const maxDur = spec.maxDurationSec ?? spec.video?.maxDurationSec;
    if (maxDur && probe.durationSec && probe.durationSec > maxDur) {
      return {
        ok: false,
        mediaType: "video",
        error: {
          code: "too_long",
          message: "Video is too long.",
          details: { durationSec: probe.durationSec, maxDurationSec: maxDur },
        },
      };
    }

    // uniform enforcement
    const requiredOri = spec.videoOrientation;
    const requiredAspect = spec.requiredAspectRatio;
    const requiredW = spec.requiredWidth;
    const requiredH = spec.requiredHeight;

    const actualOri = orientationOf(probe.width, probe.height);
    const actualAspect = aspect(probe.width, probe.height);

    const okOri = orientationOk(requiredOri, actualOri);
    const okAspect = requiredAspect ? (actualAspect ? aspectClose(actualAspect, requiredAspect) : false) : true;
    const okDims = !requiredW || !requiredH ? true : probe.width === requiredW && probe.height === requiredH;

    const needsAuto = !okOri || !okAspect || !okDims;

    if (needsAuto && !spec.allowAutoFormat) {
      if (!okOri) {
        return {
          ok: false,
          mediaType: "video",
          error: {
            code: "orientation_mismatch",
            message: "Video orientation does not match the required format.",
            details: { requiredOri, actualOri, width: probe.width, height: probe.height },
          },
        };
      }
      if (!okAspect) {
        return {
          ok: false,
          mediaType: "video",
          error: {
            code: "aspect_ratio_mismatch",
            message: "Video aspect ratio does not match the required format.",
            details: { requiredAspectRatio: requiredAspect, aspectRatio: actualAspect, width: probe.width, height: probe.height },
          },
        };
      }
      if (!okDims) {
        return {
          ok: false,
          mediaType: "video",
          error: {
            code: "dimensions_mismatch",
            message: "Video dimensions do not match the required format.",
            details: { requiredWidth: requiredW, requiredHeight: requiredH, width: probe.width, height: probe.height },
          },
        };
      }
    }

    // outputs
    const videoOut = outputPathFor(ctx.outputBasePath, "main", "mp4");
    const posterOut = outputPathFor(ctx.outputBasePath, "poster", "jpg");

    // Build a basic filter graph to enforce size/aspect when auto-format is enabled.
    // - If exact WxH required: scale+crop to WxH
    // - Else if aspect required: crop to aspect then scale to original (or keep)
    // - Else: keep original
    let vf = "";

    if (spec.allowAutoFormat) {
      if (requiredW && requiredH) {
        // scale to cover then crop exactly
        vf = `scale=${requiredW}:${requiredH}:force_original_aspect_ratio=increase,crop=${requiredW}:${requiredH}`;
      } else if (requiredAspect) {
        // crop to aspect ratio while keeping as much as possible
        // cropw/croph depend on input; use expressions
        // If too wide: crop width = ih*ar; else crop height = iw/ar
        vf = `crop='if(gt(iw/ih,${requiredAspect}),ih*${requiredAspect},iw)':'if(gt(iw/ih,${requiredAspect}),ih,iw/${requiredAspect})'`;
      }
    }

    const ffmpegArgs = [
      "-y",
      "-i",
      ctx.inputPath,
      ...(vf ? ["-vf", vf] : []),
      "-c:v",
      "libx264",
      "-preset",
      "veryfast",
      "-crf",
      "23",
      "-pix_fmt",
      "yuv420p",
      "-movflags",
      "+faststart",
      ...(probe.hasAudio ? ["-c:a", "aac", "-b:a", "128k"] : ["-an"]),
      videoOut,
    ];

    const r1 = await runCmd("ffmpeg", ffmpegArgs);
    if (r1.code !== 0) {
      return {
        ok: false,
        mediaType: "video",
        error: {
          code: "processing_failed",
          message: "ffmpeg video transcode failed.",
          details: { stderr: r1.stderr?.slice(0, 2000) },
        },
      };
    }

    // Poster (frame at 1s; fallback to 0 if needed)
    const posterArgs = ["-y", "-ss", "1", "-i", videoOut, "-frames:v", "1", "-q:v", "2", posterOut];
    const r2 = await runCmd("ffmpeg", posterArgs);
    if (r2.code !== 0) {
      // non-fatal; still succeed with video
    }

    const vs = await stat(videoOut);
    let psSize = 0;
    try {
      const ps = await stat(posterOut);
      psSize = ps.size;
    } catch {}

    const outputs: MediaOutput[] = [
      {
        key: "main",
        url: `file://${videoOut}`,
        path: videoOut,
        mime: mimeFromExt("mp4"),
        sizeBytes: vs.size,
        width: requiredW ?? probe.width,
        height: requiredH ?? probe.height,
        durationSec: probe.durationSec,
      },
    ];

    if (psSize > 0) {
      outputs.push({
        key: "poster",
        url: `file://${posterOut}`,
        path: posterOut,
        mime: "image/jpeg",
        sizeBytes: psSize,
      });
    }

    return {
      ok: true,
      mediaType: "video",
      outputs,
      meta: {
        mime: ctx.inputMime,
        sizeBytes: undefined,
        width: probe.width,
        height: probe.height,
        durationSec: probe.durationSec,
      },
      warnings: needsAuto && spec.allowAutoFormat ? ["auto_formatted"] : undefined,
    };
  } catch (e: any) {
    return {
      ok: false,
      mediaType: "video",
      error: {
        code: "processing_failed",
        message: e?.message ? String(e.message) : "Video processing failed",
        details: { name: e?.name },
      },
    };
  }
}


================================================================================
FILE PATH: packages/media-processing-core/src/workspace/temp.ts
================================================================================
import { mkdtemp, rm } from "node:fs/promises";
import os from "node:os";
import path from "node:path";

export interface TempWorkspace {
  dir: string;
  cleanup: () => Promise<void>;
}

export async function createTempWorkspace(prefix = "ttt-media-"): Promise<TempWorkspace> {
  const dir = await mkdtemp(path.join(os.tmpdir(), prefix));
  return {
    dir,
    cleanup: async () => {
      await rm(dir, { recursive: true, force: true });
    },
  };
}


================================================================================
FILE PATH: packages/media-processing-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "noEmitOnError": true,
    "types": ["node"]
  },
  "include": ["src"]
}


================================================================================
FILE PATH: packages/media-viewer/package.json
================================================================================
{
    "name": "@ttt-productions/media-viewer",
    "version": "0.2.3",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/media-viewer"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        }
    },
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
        "@ttt-productions/media-contracts": ">=0.0.0",
        "react": ">=18.0.0",
        "react-dom": ">=18.0.0"
    },
    "devDependencies": {
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/media-viewer/src/audio-viewer.tsx
================================================================================
import * as React from "react";
import type { MediaViewerBaseProps } from "./types";
import { MediaFallbackLink, shouldShowFallback } from "./fallback";

export function AudioViewer(props: MediaViewerBaseProps) {
  const {
    url,
    className,
    mediaClassName,
    onError,
    fallbackMode = "link",
    fallbackLabel
  } = props;

  const [failed, setFailed] = React.useState(false);

  if (failed) {
    return shouldShowFallback(fallbackMode) ? (
      <div className={className}>
        <MediaFallbackLink url={url} label={fallbackLabel ?? "Open audio"} />
      </div>
    ) : null;
  }

  return (
    <div className={className}>
      <audio
        src={url}
        className={mediaClassName}
        controls
        preload="metadata"
        onError={(e) => {
          setFailed(true);
          onError?.(e);
        }}
      />
    </div>
  );
}


================================================================================
FILE PATH: packages/media-viewer/src/components/media-job-status-list.tsx
================================================================================
"use client";

import type { MediaJobStatusPayload } from "@ttt-productions/media-contracts";
import { Badge, Card, Progress, cn } from "@ttt-productions/ui-core";
import { AlertCircle, CheckCircle2, Clock3, Loader2, UploadCloud, XCircle } from "lucide-react";

export interface MediaJobStatusListProps {
  items: MediaJobStatusPayload[];
  className?: string;

  /** default: 24 */
  recentHours?: number;

  /** default: true */
  showOnlyRecent?: boolean;

  /** default: 50 */
  maxItems?: number;
}

function getUpdatedAtMs(x: MediaJobStatusPayload): number {
  const v = x.updatedAt;
  if (!v) return Date.now();
  if (typeof v === "number") return v;
  const t = Date.parse(v);
  return Number.isFinite(t) ? t : Date.now();
}

function statusMeta(status: MediaJobStatusPayload["status"]) {
  switch (status) {
    case "uploading":
      return { label: "Uploading", icon: UploadCloud, badge: "secondary" as const };
    case "queued":
      return { label: "Queued", icon: Clock3, badge: "secondary" as const };
    case "processing":
      return { label: "AI Processing", icon: Loader2, badge: "secondary" as const };
    case "ready":
      return { label: "Ready", icon: CheckCircle2, badge: "default" as const };
    case "rejected":
      return { label: "Rejected", icon: XCircle, badge: "destructive" as const };
    case "failed":
      return { label: "Failed", icon: AlertCircle, badge: "destructive" as const };
    case "selecting":
      return { label: "Selecting", icon: Clock3, badge: "secondary" as const };
    default:
      return { label: String(status), icon: Clock3, badge: "secondary" as const };
  }
}

export function MediaJobStatusList(props: MediaJobStatusListProps) {
  const {
    items,
    className,
    recentHours = 24,
    showOnlyRecent = true,
    maxItems = 50,
  } = props;

  const now = Date.now();
  const cutoff = now - recentHours * 60 * 60 * 1000;

  const list = items
    .slice()
    .sort((a, b) => getUpdatedAtMs(b) - getUpdatedAtMs(a))
    .filter((x) => (showOnlyRecent ? getUpdatedAtMs(x) >= cutoff : true))
    .slice(0, maxItems);

  if (!list.length) return null;

  return (
    <Card className={cn("p-3 space-y-2", className)}>
      <div className="text-sm font-medium">Uploads</div>

      <div className="space-y-2">
        {list.map((it, idx) => {
          const meta = statusMeta(it.status);
          const Icon = meta.icon;

          const progress =
            it.status === "uploading"
              ? Math.max(0, Math.min(100, Math.round((it.progress ?? 0) * 100)))
              : it.status === "ready"
                ? 100
                : undefined;

          const updatedAt = new Date(getUpdatedAtMs(it)).toLocaleString();

          return (
            <div key={`${it.mediaDocId ?? "item"}-${idx}`} className="rounded-lg border p-2">
              <div className="flex items-center justify-between gap-2">
                <div className="flex items-center gap-2 min-w-0">
                  <Icon className={cn("h-4 w-4", it.status === "processing" ? "animate-spin" : "")} />
                  <div className="min-w-0">
                    <div className="flex items-center gap-2">
                      <Badge variant={meta.badge}>{meta.label}</Badge>
                      {it.mediaDocId ? (
                        <span className="text-xs text-muted-foreground truncate">
                          {it.mediaDocId}
                        </span>
                      ) : null}
                    </div>
                    <div className="text-xs text-muted-foreground truncate">{updatedAt}</div>
                  </div>
                </div>

                {it.reasonCode ? (
                  <span className="text-xs text-muted-foreground">{it.reasonCode}</span>
                ) : null}
              </div>

              {typeof progress === "number" ? (
                <div className="mt-2 space-y-1">
                  <Progress value={progress} />
                  <div className="text-xs text-muted-foreground">{progress}%</div>
                </div>
              ) : null}
            </div>
          );
        })}
      </div>
    </Card>
  );
}


================================================================================
FILE PATH: packages/media-viewer/src/fallback.tsx
================================================================================

import type { MediaViewerBaseProps } from "./types";

export function MediaFallbackLink(props: {
  url: string;
  filename?: string;
  className?: string;
  label?: string;
}) {
  const { url, filename, className, label } = props;

  return (
    <a
      href={url}
      target="_blank"
      rel="noreferrer"
      download={filename || undefined}
      className={className}
    >
      {label ?? "Download"}
    </a>
  );
}

export function shouldShowFallback(mode: MediaViewerBaseProps["fallbackMode"]): boolean {
  return mode !== "none";
}


================================================================================
FILE PATH: packages/media-viewer/src/image-viewer.tsx
================================================================================
import * as React from "react";
import type { MediaViewerBaseProps } from "./types";
import { MediaFallbackLink, shouldShowFallback } from "./fallback";

export function ImageViewer(props: MediaViewerBaseProps) {
  const {
    url,
    alt,
    className,
    mediaClassName,
    onError,
    fallbackMode = "link",
    fallbackLabel
  } = props;

  const [failed, setFailed] = React.useState(false);

  if (failed) {
    return shouldShowFallback(fallbackMode) ? (
      <div className={className}>
        <MediaFallbackLink url={url} label={fallbackLabel ?? "Open image"} />
      </div>
    ) : null;
  }

  return (
    <div className={className}>
      <img
        src={url}
        alt={alt ?? ""}
        loading="lazy"
        decoding="async"
        className={mediaClassName}
        onError={(e) => {
          setFailed(true);
          onError?.(e);
        }}
      />
    </div>
  );
}


================================================================================
FILE PATH: packages/media-viewer/src/index.ts
================================================================================
export * from "./types";
export * from "./media-viewer";
export * from "./image-viewer";
export * from "./video-viewer";
export * from "./audio-viewer";
export * from "./components/media-job-status-list";


================================================================================
FILE PATH: packages/media-viewer/src/media-viewer.tsx
================================================================================
import { getSimplifiedMediaType } from "@ttt-productions/media-contracts";
import type { SimplifiedMediaType } from "@ttt-productions/media-contracts";

import type { MediaViewerBaseProps, MediaViewerType } from "./types";
import { MediaFallbackLink, shouldShowFallback } from "./fallback";
import { ImageViewer } from "./image-viewer";
import { VideoViewer } from "./video-viewer";
import { AudioViewer } from "./audio-viewer";

function inferType(props: Pick<MediaViewerBaseProps, "type" | "mime" | "name" | "url">): MediaViewerType {
  if (props.type) return props.type;

  const hint = props.mime ?? props.name ?? props.url;
  const simplified: SimplifiedMediaType = getSimplifiedMediaType(hint);
  return simplified;
}

export function MediaViewer(props: MediaViewerBaseProps) {
  const {
    url,
    className,
    filename,
    fallbackMode = "link",
    fallbackLabel
  } = props;

  const t = inferType(props);

  if (t === "image") return <ImageViewer {...props} type="image" />;
  if (t === "video") return <VideoViewer {...props} type="video" />;
  if (t === "audio") return <AudioViewer {...props} type="audio" />;

  // future: pdf
  // if (t === "pdf") ...

  return shouldShowFallback(fallbackMode) ? (
    <div className={className}>
      <MediaFallbackLink
        url={url}
        filename={filename}
        label={fallbackLabel ?? "Download"}
      />
    </div>
  ) : null;
}

/** Back-compat alias */
export const MediaPreview = MediaViewer;


================================================================================
FILE PATH: packages/media-viewer/src/types.ts
================================================================================
import type { SimplifiedMediaType } from "@ttt-productions/media-contracts";

export type MediaViewerType = SimplifiedMediaType | "pdf";

export type MediaViewerFallbackMode = "link" | "none";

export interface MediaViewerBaseProps {
  url: string;

  /** Optional explicit type; otherwise inferred from mime/name/url. */
  type?: MediaViewerType;

  /** Optional hints for inference. */
  mime?: string;
  name?: string;

  /** Wrapper class */
  className?: string;

  /** Media element class */
  mediaClassName?: string;

  /** For images */
  alt?: string;

  /** For link fallback */
  filename?: string;

  /** Called when the underlying media element errors. */
  onError?: (error: unknown) => void;

  /** Generic fallback behavior when type is unknown or render fails. */
  fallbackMode?: MediaViewerFallbackMode;

  /** Link label override */
  fallbackLabel?: string;

  poster?: string;
}


================================================================================
FILE PATH: packages/media-viewer/src/video-viewer.tsx
================================================================================
import * as React from "react";
import type { MediaViewerBaseProps } from "./types";
import { MediaFallbackLink, shouldShowFallback } from "./fallback";

export function VideoViewer(props: MediaViewerBaseProps) {
  const {
    url,
    className,
    mediaClassName,
    onError,
    fallbackMode = "link",
    fallbackLabel
  } = props;

  const [failed, setFailed] = React.useState(false);

  if (failed) {
    return shouldShowFallback(fallbackMode) ? (
      <div className={className}>
        <MediaFallbackLink url={url} label={fallbackLabel ?? "Open video"} />
      </div>
    ) : null;
  }

  return (
    <div className={className}>
      <video
        src={url}
        className={mediaClassName}
        controls
        preload="metadata"
        poster={props.poster}
        playsInline
        onError={(e) => {
          setFailed(true);
          onError?.(e);
        }}
      />
    </div>
  );
}


================================================================================
FILE PATH: packages/media-viewer/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "jsx": "react-jsx"
  },
  "include": ["src"]
}


================================================================================
FILE PATH: packages/mobile-core/package.json
================================================================================
{
    "name": "@ttt-productions/mobile-core",
    "version": "0.2.3",
    "description": "Shared mobile utilities and responsive helpers for TTT Productions apps",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/mobile-core"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        }
    },
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
        "react": ">=19.0.0",
        "react-dom": ">=19.0.0"
    },
    "devDependencies": {
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/mobile-core/README.md
================================================================================
# @ttt-productions/mobile-core

Mobile UX helpers (esp. iOS Safari). No UI primitives, no Firebase, no routing.

Core exports:
- useKeyboard, KeyboardAvoidingView
- useKeepFocusedInputVisible
- useInputNavigation
- useViewportHeightVars
- SafeArea, useSafeAreaInsets
- useScrollLock
- useIosSafariFixes, useNoRubberBand


================================================================================
FILE PATH: packages/mobile-core/src/env.ts
================================================================================
export const isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
export const isIOS = isBrowser && /iP(ad|hone|od)/.test(navigator.userAgent);
export const isSafari = isBrowser && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
export const hasVisualViewport = isBrowser && !!window.visualViewport;


================================================================================
FILE PATH: packages/mobile-core/src/index.ts
================================================================================
export * from "./types";
export * from "./env";

export * from "./viewport/useVisualViewport";
export * from "./viewport/useViewportHeightVars";

export * from "./keyboard/useKeyboard";
export * from "./keyboard/useKeepFocusedInputVisible";
export * from "./keyboard/useInputNavigation";
export * from "./keyboard/KeyboardAvoidingView";

export * from "./safe-area/useSafeAreaInsets";
export * from "./safe-area/SafeArea";

export * from "./scroll/useScrollLock";

export * from "./ios/useIosSafariFixes";
export * from "./ios/useNoRubberBand";


================================================================================
FILE PATH: packages/mobile-core/src/ios/useIosSafariFixes.ts
================================================================================
import { useEffect } from "react";
import { isBrowser, isIOS, isSafari } from "../env";

/**
 * Small, safe iOS Safari fixes:
 * - disables double-tap-to-zoom delays for buttons (via touch-action)
 * - ensures inputs don't auto-zoom by recommending 16px font (cannot enforce here)
 * - adds -webkit-overflow-scrolling: touch helper class hook (optional)
 */
export function useIosSafariFixes() {
  useEffect(() => {
    if (!isBrowser || !isIOS || !isSafari) return;

    document.documentElement.classList.add("ttt-ios-safari");
    return () => document.documentElement.classList.remove("ttt-ios-safari");
  }, []);
}


================================================================================
FILE PATH: packages/mobile-core/src/ios/useNoRubberBand.ts
================================================================================
import { useEffect } from "react";
import { isBrowser, isIOS } from "../env";

/**
 * Prevents iOS rubber-band scroll on the document by limiting overscroll chaining.
 * Use sparingly (e.g., full-screen experiences).
 */
export function useNoRubberBand(enabled: boolean) {
  useEffect(() => {
    if (!isBrowser || !isIOS || !enabled) return;

    const el = document.documentElement;
    const prev = el.style.overscrollBehaviorY as any;
    (el.style as any).overscrollBehaviorY = "none";

    return () => {
      (el.style as any).overscrollBehaviorY = prev;
    };
  }, [enabled]);
}


================================================================================
FILE PATH: packages/mobile-core/src/keyboard/focusOrder.ts
================================================================================
export function getFocusableInputs(root: HTMLElement | Document = document) {
  const el = root instanceof Document ? root : root;
  const list = Array.from(
    el.querySelectorAll<HTMLElement>(
      'input, textarea, select, [contenteditable="true"], [data-ttt-input]'
    )
  ).filter((n) => !n.hasAttribute("disabled") && n.tabIndex !== -1);

  // DOM order is usually correct; allow explicit override
  list.sort((a, b) => {
    const ao = Number(a.getAttribute("data-input-order") ?? "0");
    const bo = Number(b.getAttribute("data-input-order") ?? "0");
    if (ao && bo) return ao - bo;
    if (ao) return -1;
    if (bo) return 1;
    return 0;
  });

  return list;
}


================================================================================
FILE PATH: packages/mobile-core/src/keyboard/KeyboardAvoidingView.tsx
================================================================================
import React from "react";
import { useKeyboard } from "./useKeyboard";

type Props = React.HTMLAttributes<HTMLDivElement> & {
  /**
   * If true, adds padding-bottom equal to keyboard height while open.
   * Good default for forms.
   */
  padding?: boolean;
  /**
   * Adds extra px to bottom padding.
   */
  offset?: number;
};

/**
 * Desktop-safe: does nothing when keyboard is not detected.
 */
export function KeyboardAvoidingView({ padding = true, offset = 0, style, ...rest }: Props) {
  const k = useKeyboard();
  const pb = padding && k.isOpen ? k.height + offset : 0;

  return <div {...rest} style={{ ...style, paddingBottom: (style as any)?.paddingBottom ?? pb }} />;
}


================================================================================
FILE PATH: packages/mobile-core/src/keyboard/useInputNavigation.ts
================================================================================
import { useCallback } from "react";
import { getFocusableInputs } from "./focusOrder";

type Options = {
  root?: HTMLElement | null; // scope inputs
  onDone?: () => void;
};

/**
 * Attach to inputs:
 *  onKeyDown={nav.onKeyDown}
 *  onSubmitEditing={nav.onSubmitEditing} (optional)
 *
 * Also supports explicit ordering via data-input-order.
 */
export function useInputNavigation(opts?: Options) {
  const root = opts?.root ?? null;

  const focusNext = useCallback(() => {
    const scope = root ?? document;
    const inputs = getFocusableInputs(scope as any);
    const active = document.activeElement as HTMLElement | null;
    const idx = active ? inputs.indexOf(active) : -1;
    const next = inputs[idx + 1];

    if (next) next.focus();
    else opts?.onDone?.();
  }, [root, opts]);

  const onKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === "Enter") {
        // allow textarea newlines
        const el = e.currentTarget as HTMLElement;
        if (el.tagName.toLowerCase() === "textarea") return;
        e.preventDefault();
        focusNext();
      }
    },
    [focusNext]
  );

  return { focusNext, onKeyDown };
}


================================================================================
FILE PATH: packages/mobile-core/src/keyboard/useKeepFocusedInputVisible.ts
================================================================================
import { useEffect } from "react";
import { isBrowser } from "../env";
import { useKeyboard } from "./useKeyboard";

/**
 * When keyboard opens, ensure focused element is visible within visual viewport.
 * - iOS Safari often hides the caret behind the keyboard.
 */
export function useKeepFocusedInputVisible(opts?: {
  extraOffset?: number; // px
  scrollBehavior?: ScrollBehavior; // "smooth" | "auto"
}) {
  const { isOpen } = useKeyboard();
  const extraOffset = opts?.extraOffset ?? 12;
  const behavior = opts?.scrollBehavior ?? "smooth";

  useEffect(() => {
    if (!isBrowser) return;
    if (!isOpen) return;

    const el = document.activeElement as HTMLElement | null;
    if (!el) return;

    // only inputs-ish
    const tag = el.tagName.toLowerCase();
    const isInput =
      tag === "input" || tag === "textarea" || tag === "select" || el.isContentEditable || el.hasAttribute("data-ttt-input");
    if (!isInput) return;

    const vv = window.visualViewport;
    const vvH = vv?.height ?? window.innerHeight;
    const rect = el.getBoundingClientRect();
    const bottom = rect.bottom;
    const limit = vvH - extraOffset;

    if (bottom > limit) {
      const delta = bottom - limit;
      window.scrollBy({ top: delta, behavior });
    }
  }, [isOpen, extraOffset, behavior]);
}


================================================================================
FILE PATH: packages/mobile-core/src/keyboard/useKeyboard.ts
================================================================================
import { useEffect, useMemo, useState } from "react";
import { hasVisualViewport, isBrowser } from "../env";
import type { KeyboardState } from "../types";

/**
 * Best effort keyboard detection:
 * - iOS Safari: visualViewport.height shrinks when keyboard shows
 * - fallback: focusin/focusout heuristics + innerHeight snapshots
 */
export function useKeyboard(): KeyboardState {
  const [baseline, setBaseline] = useState<number>(() => (isBrowser ? window.innerHeight : 0));
  const [height, setHeight] = useState(0);
  const [open, setOpen] = useState(false);
  const [source, setSource] = useState<KeyboardState["source"]>("fallback");

  useEffect(() => {
    if (!isBrowser) return;

    const setBaseIfNeeded = () => {
      // update baseline when keyboard likely closed
      const vvH = window.visualViewport?.height ?? window.innerHeight;
      const inner = window.innerHeight;
      const candidate = Math.max(vvH, inner);
      setBaseline((b) => (Math.abs(candidate - b) > 40 ? candidate : b));
    };

    const onVV = () => {
      const vvH = window.visualViewport?.height ?? window.innerHeight;
      const delta = Math.max(0, Math.round(baseline - vvH));
      const isOpen = delta > 80; // threshold
      setSource("visualViewport");
      setHeight(isOpen ? delta : 0);
      setOpen(isOpen);
      if (!isOpen) setBaseIfNeeded();
    };

    const onFocusIn = () => {
      // baseline snapshot on focus to reduce false positives
      setBaseline((b) => Math.max(b, window.innerHeight));
    };
    const onFocusOut = () => {
      // allow baseline update shortly after blur
      setTimeout(setBaseIfNeeded, 50);
      setTimeout(() => {
        setOpen(false);
        setHeight(0);
      }, 250);
    };

    if (hasVisualViewport) {
      window.visualViewport!.addEventListener("resize", onVV, { passive: true });
      window.visualViewport!.addEventListener("scroll", onVV, { passive: true });
      onVV();
    }

    window.addEventListener("focusin", onFocusIn, { passive: true } as any);
    window.addEventListener("focusout", onFocusOut, { passive: true } as any);
    window.addEventListener("orientationchange", setBaseIfNeeded, { passive: true });

    setBaseIfNeeded();

    return () => {
      if (hasVisualViewport) {
        window.visualViewport!.removeEventListener("resize", onVV);
        window.visualViewport!.removeEventListener("scroll", onVV);
      }
      window.removeEventListener("focusin", onFocusIn as any);
      window.removeEventListener("focusout", onFocusOut as any);
      window.removeEventListener("orientationchange", setBaseIfNeeded);
    };
  }, [baseline]);

  return useMemo(() => ({ isOpen: open, height, source }), [open, height, source]);
}


================================================================================
FILE PATH: packages/mobile-core/src/safe-area/SafeArea.tsx
================================================================================
import React from "react";

type Props = React.HTMLAttributes<HTMLDivElement> & {
  top?: boolean;
  bottom?: boolean;
  left?: boolean;
  right?: boolean;
};

export function SafeArea({ top, bottom, left, right, style, ...rest }: Props) {
  return (
    <div
      {...rest}
      style={{
        ...style,
        paddingTop: top ? "env(safe-area-inset-top)" : (style as any)?.paddingTop,
        paddingBottom: bottom ? "env(safe-area-inset-bottom)" : (style as any)?.paddingBottom,
        paddingLeft: left ? "env(safe-area-inset-left)" : (style as any)?.paddingLeft,
        paddingRight: right ? "env(safe-area-inset-right)" : (style as any)?.paddingRight,
      }}
    />
  );
}


================================================================================
FILE PATH: packages/mobile-core/src/safe-area/useSafeAreaInsets.ts
================================================================================
import { useEffect, useState } from "react";
import type { Insets } from "../types";
import { isBrowser } from "../env";

/**
 * Uses CSS env(safe-area-inset-*) by writing them to CSS vars and reading computed values.
 * Works on iOS Safari; harmless elsewhere.
 */
export function useSafeAreaInsets(): Insets {
  const [insets, setInsets] = useState<Insets>({ top: 0, right: 0, bottom: 0, left: 0 });

  useEffect(() => {
    if (!isBrowser) return;

    const el = document.documentElement;

    // set vars once
    el.style.setProperty("--ttt-sai-top", "env(safe-area-inset-top)");
    el.style.setProperty("--ttt-sai-right", "env(safe-area-inset-right)");
    el.style.setProperty("--ttt-sai-bottom", "env(safe-area-inset-bottom)");
    el.style.setProperty("--ttt-sai-left", "env(safe-area-inset-left)");

    const read = () => {
      const cs = getComputedStyle(el);
      const px = (v: string) => Math.max(0, Math.round(parseFloat(v || "0")));
      setInsets({
        top: px(cs.getPropertyValue("--ttt-sai-top")),
        right: px(cs.getPropertyValue("--ttt-sai-right")),
        bottom: px(cs.getPropertyValue("--ttt-sai-bottom")),
        left: px(cs.getPropertyValue("--ttt-sai-left")),
      });
    };

    read();
    window.addEventListener("resize", read, { passive: true });
    window.addEventListener("orientationchange", read, { passive: true });
    return () => {
      window.removeEventListener("resize", read);
      window.removeEventListener("orientationchange", read);
    };
  }, []);

  return insets;
}


================================================================================
FILE PATH: packages/mobile-core/src/scroll/useScrollLock.ts
================================================================================
import { useEffect } from "react";
import { isBrowser } from "../env";

/**
 * Locks body scroll (mobile sheet/modal fix).
 * - preserves current scroll position
 * - iOS safe enough for common cases
 */
export function useScrollLock(locked: boolean) {
  useEffect(() => {
    if (!isBrowser) return;
    if (!locked) return;

    const { body } = document;
    const scrollY = window.scrollY;

    const prev = {
      position: body.style.position,
      top: body.style.top,
      width: body.style.width,
      overflowY: body.style.overflowY,
    };

    body.style.position = "fixed";
    body.style.top = `-${scrollY}px`;
    body.style.width = "100%";
    body.style.overflowY = "scroll";

    return () => {
      body.style.position = prev.position;
      body.style.top = prev.top;
      body.style.width = prev.width;
      body.style.overflowY = prev.overflowY;
      window.scrollTo(0, scrollY);
    };
  }, [locked]);
}


================================================================================
FILE PATH: packages/mobile-core/src/types.ts
================================================================================
export type Insets = { top: number; right: number; bottom: number; left: number };

export type KeyboardState = {
  isOpen: boolean;
  height: number; // px
  // best-effort: iOS visualViewport + focus heuristics
  source: "visualViewport" | "fallback";
};


================================================================================
FILE PATH: packages/mobile-core/src/viewport/useViewportHeightVars.ts
================================================================================
import { useEffect } from "react";
import { isBrowser } from "../env";

/**
 * Sets:
 *  --ttt-vh: 1% of *layout* viewport height (window.innerHeight)
 *  --ttt-dvh: 1% of *visual* viewport height (visualViewport.height when available)
 *
 * Use in CSS:
 *  height: calc(var(--ttt-dvh, var(--ttt-vh, 1vh)) * 100);
 */
export function useViewportHeightVars() {
  useEffect(() => {
    if (!isBrowser) return;

    const apply = () => {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty("--ttt-vh", `${vh}px`);

      const dvh = (window.visualViewport?.height ?? window.innerHeight) * 0.01;
      document.documentElement.style.setProperty("--ttt-dvh", `${dvh}px`);
    };

    apply();
    window.addEventListener("resize", apply, { passive: true });
    window.visualViewport?.addEventListener("resize", apply, { passive: true });
    return () => {
      window.removeEventListener("resize", apply);
      window.visualViewport?.removeEventListener("resize", apply);
    };
  }, []);
}


================================================================================
FILE PATH: packages/mobile-core/src/viewport/useVisualViewport.ts
================================================================================
import { useEffect, useState } from "react";
import { hasVisualViewport, isBrowser } from "../env";

export function useVisualViewport() {
  const vv = isBrowser && hasVisualViewport ? window.visualViewport! : null;

  const [state, setState] = useState(() => ({
    width: vv?.width ?? 0,
    height: vv?.height ?? 0,
    scale: vv?.scale ?? 1,
    offsetTop: vv?.offsetTop ?? 0,
    offsetLeft: vv?.offsetLeft ?? 0,
    pageTop: vv?.pageTop ?? 0,
    pageLeft: vv?.pageLeft ?? 0,
  }));

  useEffect(() => {
    if (!vv) return;

    const onChange = () =>
      setState({
        width: vv.width,
        height: vv.height,
        scale: vv.scale,
        offsetTop: vv.offsetTop,
        offsetLeft: vv.offsetLeft,
        pageTop: vv.pageTop,
        pageLeft: vv.pageLeft,
      });

    onChange();
    vv.addEventListener("resize", onChange, { passive: true });
    vv.addEventListener("scroll", onChange, { passive: true });

    return () => {
      vv.removeEventListener("resize", onChange);
      vv.removeEventListener("scroll", onChange);
    };
  }, [vv]);

  return { visualViewport: vv, ...state };
}


================================================================================
FILE PATH: packages/mobile-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}


================================================================================
FILE PATH: packages/monitoring-core/package.json
================================================================================
{
    "name": "@ttt-productions/monitoring-core",
    "version": "0.2.3",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/monitoring-core"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        }
    },
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
        "@sentry/nextjs": ">=8.0.0",
        "@sentry/node": ">=8.0.0"
    },
    "peerDependenciesMeta": {
        "@sentry/nextjs": {
            "optional": true
        },
        "@sentry/node": {
            "optional": true
        }
    },
    "devDependencies": {
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/monitoring-core/src/adapters/noop.ts
================================================================================
import type { MonitoringAdapter } from "../adapter";
import type { MonitoringInitOptions, MonitoringUser, ScopeLike } from "../types";

const noopScope: ScopeLike = {
  setTag: () => {},
  setUser: () => {},
  setExtra: () => {},
  setContext: () => {},
};

export const NoopAdapter: MonitoringAdapter = {
  init: (_options: MonitoringInitOptions) => {},

  captureException: (_error: unknown, _context?: Record<string, unknown>) => {},
  captureMessage: (_message: string, _level?: any) => {},

  setUser: (_user: MonitoringUser | null) => {},
  setTag: (_key: string, _value: string) => {},

  withScope: <T>(fn: (scope: ScopeLike) => T) => fn(noopScope),
  
  addBreadcrumb: (_breadcrumb: {
    category?: string;
    message?: string;
    level?: "fatal" | "error" | "warning" | "info" | "debug";
    data?: Record<string, unknown>;
  }) => {},
};

================================================================================
FILE PATH: packages/monitoring-core/src/adapters/sentry-node.ts
================================================================================
import type { MonitoringAdapter } from "../adapter";
import type { MonitoringInitOptions, MonitoringUser, ScopeLike } from "../types";

type SentryNodeLike = {
  init: (opts: any) => void;
  captureException: (e: unknown, hint?: any) => void;
  captureMessage: (m: string, level?: any) => void;
  setUser: (u: any) => void;
  setTag: (k: string, v: string) => void;
  withScope: (fn: (scope: any) => void) => void;
  addBreadcrumb: (breadcrumb: any) => void;
};

let sentryNodePromise: Promise<SentryNodeLike> | null = null;

function getSentryNode(): Promise<SentryNodeLike> {
  if (!sentryNodePromise) {
    sentryNodePromise = (Function("return import('@sentry/node')")() as Promise<any>).then(
      (m) => m as SentryNodeLike
    );
  }
  return sentryNodePromise;
}

export const SentryNodeAdapter: MonitoringAdapter = {
  async init(options: MonitoringInitOptions) {
    const enabled = options.enabled ?? true;
    if (!enabled || !options.dsn) return;

    const S = await getSentryNode();
    S.init({
      dsn: options.dsn,
      environment: options.environment,
      enabled: true,
      release: options.release,
    });
  },

  captureException(error: unknown, context?: Record<string, unknown>) {
    void (async () => {
      const S = await getSentryNode();

      if (context) {
        S.withScope((scope) => {
          for (const [k, v] of Object.entries(context)) {
            if (typeof scope?.setExtra === "function") scope.setExtra(k, v);
          }
          S.captureException(error);
        });
        return;
      }

      S.captureException(error);
    })();
  },

  captureMessage(message: string, level?: any) {
    void (async () => {
      const S = await getSentryNode();
      S.captureMessage(message, level);
    })();
  },

  setUser(user: MonitoringUser | null) {
    void (async () => {
      const S = await getSentryNode();
      S.setUser(user as any);
    })();
  },

  setTag(key: string, value: string) {
    void (async () => {
      const S = await getSentryNode();
      S.setTag(key, value);
    })();
  },

  withScope<T>(fn: (scope: ScopeLike) => T): T {
    const minimalScope: ScopeLike = {
      setTag: () => {},
      setUser: () => {},
      setExtra: () => {},
      setContext: () => {},
    };

    void (async () => {
      const S = await getSentryNode();
      S.withScope((scope) => fn(scope as any));
    })();

    return fn(minimalScope);
  },

  addBreadcrumb(breadcrumb: {
    category?: string;
    message?: string;
    level?: "fatal" | "error" | "warning" | "info" | "debug";
    data?: Record<string, unknown>;
  }) {
    void (async () => {
      const S = await getSentryNode();
      S.addBreadcrumb(breadcrumb);
    })();
  },
};

================================================================================
FILE PATH: packages/monitoring-core/src/adapters/sentry.ts
================================================================================
import type { MonitoringAdapter } from "../adapter";
import type { MonitoringInitOptions, MonitoringUser, ScopeLike } from "../types";

type SentryLike = {
  init: (opts: any) => void;
  captureException: (e: unknown) => void;
  captureMessage: (m: string, level?: any) => void;
  setUser: (u: any) => void;
  setTag: (k: string, v: string) => void;
  withScope?: (fn: (scope: any) => void) => void;
  addBreadcrumb?: (breadcrumb: any) => void;
};

let sentryPromise: Promise<SentryLike> | null = null;

function getSentry(): Promise<SentryLike> {
  if (!sentryPromise) {
    // keep the import fully dynamic and untyped so TS doesn't require the module at build time
    sentryPromise = (Function("return import('@sentry/nextjs')")() as Promise<any>).then(
      (m) => m as SentryLike
    );
  }
  return sentryPromise;
}

export const SentryAdapter: MonitoringAdapter = {
  async init(options: MonitoringInitOptions) {
    const enabled = options.enabled ?? true;
    if (!enabled || !options.dsn) return;

    const S = await getSentry();
    S.init({
      dsn: options.dsn,
      environment: options.environment,
      enabled: true,
      release: options.release,
    });
  },

  captureException(error: unknown, context?: Record<string, unknown>) {
    void (async () => {
      const S = await getSentry();

      if (context && S.withScope) {
        S.withScope((scope) => {
          for (const [k, v] of Object.entries(context)) {
            if (typeof scope?.setExtra === "function") scope.setExtra(k, v);
          }
          S.captureException(error);
        });
        return;
      }

      S.captureException(error);
    })();
  },

  captureMessage(message: string, level?: any) {
    void (async () => {
      const S = await getSentry();
      S.captureMessage(message, level);
    })();
  },

  setUser(user: MonitoringUser | null) {
    void (async () => {
      const S = await getSentry();
      S.setUser(user as any);
    })();
  },

  setTag(key: string, value: string) {
    void (async () => {
      const S = await getSentry();
      S.setTag(key, value);
    })();
  },

  withScope<T>(fn: (scope: ScopeLike) => T): T {
    // run immediately (sync) with a minimal scope.
    // also try to run in real Sentry scope when available.
    const minimalScope: ScopeLike = {
      setTag: () => {},
      setUser: () => {},
      setExtra: () => {},
      setContext: () => {},
    };

    void (async () => {
      const S = await getSentry();
      if (!S.withScope) return;
      S.withScope((scope) => fn(scope as any));
    })();

    return fn(minimalScope);
  },

  addBreadcrumb(breadcrumb: {
    category?: string;
    message?: string;
    level?: "fatal" | "error" | "warning" | "info" | "debug";
    data?: Record<string, unknown>;
  }) {
    void (async () => {
      const S = await getSentry();
      if (S.addBreadcrumb) {
        S.addBreadcrumb(breadcrumb);
      }
    })();
  },
};

================================================================================
FILE PATH: packages/monitoring-core/src/adapter.ts
================================================================================
import type { MonitoringInitOptions, MonitoringUser, ScopeLike } from "./types";

export interface MonitoringAdapter {
  init(options: MonitoringInitOptions): void | Promise<void>;

  captureException(error: unknown, context?: Record<string, unknown>): void;
  captureMessage(
    message: string,
    level?: "fatal" | "error" | "warning" | "info" | "debug"
  ): void;

  setUser(user: MonitoringUser | null): void;
  setTag(key: string, value: string): void;

  withScope?<T>(fn: (scope: ScopeLike) => T): T;
  
  addBreadcrumb?(breadcrumb: {
    category?: string;
    message?: string;
    level?: "fatal" | "error" | "warning" | "info" | "debug";
    data?: Record<string, unknown>;
  }): void;
}

================================================================================
FILE PATH: packages/monitoring-core/src/api.ts
================================================================================
import type { MonitoringUser } from "./types";
import { getMonitoringAdapter } from "./init";

export function captureException(error: unknown, context?: Record<string, unknown>) {
  return getMonitoringAdapter().captureException(error, context);
}

export function captureMessage(
  message: string,
  level?: "fatal" | "error" | "warning" | "info" | "debug"
) {
  return getMonitoringAdapter().captureMessage(message, level);
}

export function setUser(user: MonitoringUser | null) {
  return getMonitoringAdapter().setUser(user);
}

export function setTag(key: string, value: string) {
  return getMonitoringAdapter().setTag(key, value);
}

export function withScope(fn: (scope: any) => any) {
  const a = getMonitoringAdapter();
  return a.withScope ? a.withScope(fn as any) : fn({
    setTag: () => {},
    setUser: () => {},
    setExtra: () => {},
    setContext: () => {},
  });
}

export function addBreadcrumb(breadcrumb: {
  category?: string;
  message?: string;
  level?: "fatal" | "error" | "warning" | "info" | "debug";
  data?: Record<string, unknown>;
}) {
  const a = getMonitoringAdapter();
  if (a.addBreadcrumb) {
    a.addBreadcrumb(breadcrumb);
  }
}

================================================================================
FILE PATH: packages/monitoring-core/src/index.ts
================================================================================
export type { MonitoringInitOptions, MonitoringUser, MonitoringProvider, ScopeLike } from "./types";

export { initMonitoring } from "./init";
export { captureException, captureMessage, setUser, setTag, withScope, addBreadcrumb } from "./api";

================================================================================
FILE PATH: packages/monitoring-core/src/init.ts
================================================================================
import type { MonitoringAdapter } from "./adapter";
import type { MonitoringInitOptions } from "./types";
import { NoopAdapter } from "./adapters/noop";
import { SentryAdapter } from "./adapters/sentry";
import { SentryNodeAdapter } from "./adapters/sentry-node";

let adapter: MonitoringAdapter = NoopAdapter;
let initialized = false;

export function getMonitoringAdapter(): MonitoringAdapter {
  return adapter;
}

export async function initMonitoring(options: MonitoringInitOptions): Promise<void> {
  if (initialized) return;

  const enabled = options.enabled ?? true;

  if (!enabled || options.provider === "noop") {
    adapter = NoopAdapter;
    initialized = true;
    return;
  }

  if (options.provider === "sentry") {
    adapter = SentryAdapter;
    await adapter.init(options);
    initialized = true;
    return;
  }

  if (options.provider === "sentry-node") {
    adapter = SentryNodeAdapter;
    await adapter.init(options);
    initialized = true;
    return;
  }

  adapter = NoopAdapter;
  initialized = true;
}

================================================================================
FILE PATH: packages/monitoring-core/src/types.ts
================================================================================
export type MonitoringProvider = "sentry" | "sentry-node" | "noop";

export type MonitoringInitOptions = {
  provider: MonitoringProvider;
  dsn?: string;
  environment?: string;
  enabled?: boolean; // default true
  release?: string;
};

export type MonitoringUser = {
  id?: string;
  email?: string;
  username?: string;
  ip_address?: string;
};

export type ScopeLike = {
  setTag: (key: string, value: string) => void;
  setUser: (user: MonitoringUser | null) => void;
  setExtra: (key: string, value: unknown) => void;
  setContext: (key: string, context: Record<string, unknown>) => void;
};

================================================================================
FILE PATH: packages/monitoring-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}


================================================================================
FILE PATH: packages/query-core/package.json
================================================================================
{
    "name": "@ttt-productions/query-core",
    "version": "0.3.2",
    "description": "Shared TanStack Query (React Query) client defaults, query key helpers, and Firestore integration hooks for TTT Productions apps",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/query-core"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        }
    },
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
        "@tanstack/react-query": ">=5.0.0",
        "firebase": ">=10.0.0",
        "react": ">=18.0.0",
        "react-dom": ">=18.0.0"
    },
    "peerDependenciesMeta": {
        "firebase": {
            "optional": true
        }
    },
    "devDependencies": {
        "@tanstack/react-query": "^5.0.0",
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "firebase": "^11.0.0",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/query-core/README.md
================================================================================
# @ttt-productions/query-core

Shared TanStack Query (React Query) setup for TTT Productions apps.

- `createTTTQueryClient()` factory with safe defaults
- `keys` query key helpers
- invalidation + cache update helpers
- `TTTQueryProvider` for Next.js/React apps

No app business logic. No Firebase.


================================================================================
FILE PATH: packages/query-core/src/cache-helpers.ts
================================================================================
import type { QueryClient, QueryKey } from '@tanstack/react-query';

/** Invalidate everything that matches a key prefix. */
export async function invalidateByPrefix(client: QueryClient, prefix: QueryKey) {
  return client.invalidateQueries({ queryKey: prefix, exact: false });
}

/** Remove everything that matches a key prefix (drops cached data). */
export function removeByPrefix(client: QueryClient, prefix: QueryKey) {
  return client.removeQueries({ queryKey: prefix, exact: false });
}

/**
 * Generic cache update helper.
 * Useful for optimistic updates without baking in business logic.
 */
export function updateQueryData<T>(
  client: QueryClient,
  key: QueryKey,
  updater: (prev: T | undefined) => T
) {
  client.setQueryData<T>(key, (prev) => updater(prev));
}


================================================================================
FILE PATH: packages/query-core/src/defaults.ts
================================================================================
import type { DefaultOptions, QueryClientConfig } from '@tanstack/react-query';

/**
 * Small, conservative defaults intended to work well across apps.
 * Apps can override via `createTTTQueryClient({ defaultOptions: ... })`.
 */
export const tttDefaultOptions: DefaultOptions = {
  queries: {
    refetchOnWindowFocus: false,
    refetchOnReconnect: true,
    refetchOnMount: false,

    staleTime: 30_000, // 30s
    gcTime: 5 * 60_000, // 5m

    retry: (failureCount) => failureCount < 2,
  },
  mutations: {
    retry: 0,
  },
};

export const tttQueryClientConfig: QueryClientConfig = {
  defaultOptions: tttDefaultOptions,
};


================================================================================
FILE PATH: packages/query-core/src/firestore/context.tsx
================================================================================
'use client';

import { createContext, useContext, type ReactNode } from 'react';
import type { Firestore } from 'firebase/firestore';

interface FirestoreContextValue {
  db: Firestore;
}

const FirestoreContext = createContext<FirestoreContextValue | null>(null);

export interface FirestoreProviderProps {
  db: Firestore;
  children: ReactNode;
}

/**
 * Provides Firestore instance to all useFirestore* hooks.
 * Wrap your app with this provider alongside TTTQueryProvider.
 * 
 * @example
 * ```tsx
 * import { db } from '@/lib/firebase';
 * 
 * <TTTQueryProvider>
 *   <FirestoreProvider db={db}>
 *     {children}
 *   </FirestoreProvider>
 * </TTTQueryProvider>
 * ```
 */
export function FirestoreProvider({ db, children }: FirestoreProviderProps) {
  return (
    <FirestoreContext.Provider value={{ db }}>
      {children}
    </FirestoreContext.Provider>
  );
}

/**
 * Access the Firestore instance from context.
 * Throws if used outside of FirestoreProvider.
 */
export function useFirestoreDb(): Firestore {
  const context = useContext(FirestoreContext);
  if (!context) {
    throw new Error(
      'useFirestoreDb must be used within a FirestoreProvider. ' +
      'Wrap your app with <FirestoreProvider db={db}>.'
    );
  }
  return context.db;
}


================================================================================
FILE PATH: packages/query-core/src/firestore/index.ts
================================================================================
// Context & Provider
export { FirestoreProvider, useFirestoreDb } from './context';
export type { FirestoreProviderProps } from './context';

// Types
export type {
  WithId,
  FirestoreBaseOptions,
  FirestoreDocOptions,
  FirestoreCollectionOptions,
  FirestoreInfiniteOptions,
  FirestorePaginatedOptions,
  InfinitePage,
  PaginatedResult,
  MutationOperation,
  FirestoreMutationOptions,
  FirestoreBatchOptions,
} from './types';
export { docWithId } from './types';

// Query Hooks
export { useFirestoreDoc } from './use-firestore-doc';
export { useFirestoreCollection } from './use-firestore-collection';
export { 
  useFirestoreInfinite, 
  flattenInfiniteData, 
  getInfiniteDataCount 
} from './use-firestore-infinite';
export { useFirestorePaginated } from './use-firestore-paginated';
export type { UseFirestorePaginatedResult } from './use-firestore-paginated';

// Mutation Hooks
export {
  useFirestoreSet,
  useFirestoreUpdate,
  useFirestoreDelete,
  useFirestoreBatch,
} from './use-firestore-mutations';


================================================================================
FILE PATH: packages/query-core/src/firestore/types.ts
================================================================================
import type {
  DocumentData,
  DocumentSnapshot,
  QueryDocumentSnapshot,
  QueryConstraint,
} from 'firebase/firestore';

/**
 * Document with ID included in the data object.
 */
export type WithId<T> = T & { id: string };

/**
 * Extract document data with ID from a QueryDocumentSnapshot.
 */
export function docWithId<T extends DocumentData>(
  snap: QueryDocumentSnapshot<T>
): WithId<T> {
  return { id: snap.id, ...snap.data() };
}

/**
 * Base options shared across all Firestore hooks.
 */
export interface FirestoreBaseOptions {
  /** React Query cache key */
  queryKey: readonly unknown[];
  /** Enable/disable the query */
  enabled?: boolean;
  /** Stale time override (ms) */
  staleTime?: number;
  /** Garbage collection time override (ms) */
  gcTime?: number;
}

/**
 * Options for single document queries.
 */
export interface FirestoreDocOptions<T> extends FirestoreBaseOptions {
  /** Full document path (e.g., 'users/abc123') */
  docPath: string;
  /** Enable realtime updates via onSnapshot (default: false) */
  subscribe?: boolean;
  /** Transform function applied to document data. Receives data WITH id included. */
  select?: (data: DocumentData & { id: string }) => T;
}

/**
 * Options for collection queries.
 */
export interface FirestoreCollectionOptions<T> extends FirestoreBaseOptions {
  /** Collection path (e.g., 'users' or 'projects/abc/members') */
  collectionPath: string;
  /** Firestore query constraints (where, orderBy, etc.) */
  constraints?: QueryConstraint[];
  /** Enable realtime updates via onSnapshot (default: false) */
  subscribe?: boolean;
  /** Transform function applied to each document. Receives data WITH id included. */
  select?: (data: DocumentData & { id: string }) => T;
}

/**
 * Options for infinite scroll queries.
 */
export interface FirestoreInfiniteOptions<T> extends FirestoreBaseOptions {
  /** Collection path */
  collectionPath: string;
  /** Firestore query constraints (where, orderBy - required for pagination) */
  constraints?: QueryConstraint[];
  /** Number of items per page (default: 20) */
  pageSize?: number;
  /** Transform function applied to each document. Receives data WITH id included. */
  select?: (data: DocumentData & { id: string }) => T;
}

/**
 * Options for paginated queries with page numbers.
 */
export interface FirestorePaginatedOptions<T> extends FirestoreBaseOptions {
  /** Collection path */
  collectionPath: string;
  /** Firestore query constraints */
  constraints?: QueryConstraint[];
  /** Number of items per page (default: 10) */
  pageSize?: number;
  /** Initial page number (default: 1) */
  initialPage?: number;
  /** Transform function applied to each document. Receives data WITH id included. */
  select?: (data: DocumentData & { id: string }) => T;
}

/**
 * Result page for infinite queries.
 */
export interface InfinitePage<T> {
  items: WithId<T>[];
  lastDoc: DocumentSnapshot | null;
  size: number;
}

/**
 * Result for paginated queries.
 */
export interface PaginatedResult<T> {
  items: WithId<T>[];
  cursors: DocumentSnapshot[];
  hasMore: boolean;
}

/**
 * Mutation operation types for batch mutations.
 */
export type MutationOperation =
  | { type: 'set'; docPath: string; data: DocumentData; merge?: boolean }
  | { type: 'update'; docPath: string; data: DocumentData }
  | { type: 'delete'; docPath: string };

/**
 * Options for document mutations.
 */
export interface FirestoreMutationOptions<T> {
  /** Document path for single-doc mutations */
  docPath?: string;
  /** Query keys to invalidate on success */
  invalidateKeys?: readonly unknown[][];
  /** Enable optimistic updates */
  optimistic?: {
    /** Query key of the cache to update */
    queryKey: readonly unknown[];
    /** How to update the cached data */
    updater: (oldData: T | undefined, newData: Partial<T>) => T;
  };
}

/**
 * Options for batch mutations.
 */
export interface FirestoreBatchOptions {
  /** Query keys to invalidate on success */
  invalidateKeys?: readonly unknown[][];
  /** Max operations per batch (default: 450) */
  batchSize?: number;
}


================================================================================
FILE PATH: packages/query-core/src/firestore/use-firestore-collection.ts
================================================================================
'use client';

import { useEffect } from 'react';
import { useQuery, useQueryClient, type UseQueryResult } from '@tanstack/react-query';
import {
  collection,
  query,
  getDocs,
  onSnapshot,
  type DocumentData,
} from 'firebase/firestore';
import { useFirestoreDb } from './context';
import type { FirestoreCollectionOptions, WithId } from './types';

/**
 * Fetch all documents from a Firestore collection with optional realtime updates.
 * Use this for small collections where you need all documents at once.
 * For large collections, use useFirestoreInfinite or useFirestorePaginated.
 * 
 * @example
 * ```tsx
 * // Fetch all channels in a project
 * const { data: channels } = useFirestoreCollection<Channel>({
 *   collectionPath: `projects/${projectId}/channels`,
 *   queryKey: ['channels', projectId],
 *   constraints: [orderBy('createdAt', 'asc')],
 * });
 * 
 * // With realtime updates
 * const { data: members } = useFirestoreCollection<Member>({
 *   collectionPath: `projects/${projectId}/members`,
 *   queryKey: ['members', projectId],
 *   subscribe: true,
 * });
 * ```
 */
export function useFirestoreCollection<T extends DocumentData = DocumentData>({
  collectionPath,
  queryKey,
  constraints = [],
  enabled = true,
  subscribe = false,
  staleTime,
  gcTime,
  select,
}: FirestoreCollectionOptions<T>): UseQueryResult<WithId<T>[], Error> {
  const db = useFirestoreDb();
  const queryClient = useQueryClient();

  // Set up realtime subscription
  useEffect(() => {
    if (!subscribe || !enabled) return;

    const collectionRef = collection(db, collectionPath);
    const q = constraints.length > 0 
      ? query(collectionRef, ...constraints) 
      : collectionRef;

    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        const items = snapshot.docs.map((docSnap) => {
          const rawData = docSnap.data();
          // Include id in data passed to select, so it can be renamed/transformed
          const dataWithId = { id: docSnap.id, ...rawData };
          const data = select ? select(dataWithId) : dataWithId;
          return data as WithId<T>;
        });
        queryClient.setQueryData(queryKey, items);
      },
      (error) => {
        console.error('[useFirestoreCollection] Subscription error:', error);
      }
    );

    return () => unsubscribe();
  }, [db, collectionPath, queryKey, constraints, enabled, subscribe, select, queryClient]);

  return useQuery({
    queryKey,
    queryFn: async (): Promise<WithId<T>[]> => {
      const collectionRef = collection(db, collectionPath);
      const q = constraints.length > 0 
        ? query(collectionRef, ...constraints) 
        : collectionRef;

      const snapshot = await getDocs(q);
      return snapshot.docs.map((docSnap) => {
        const rawData = docSnap.data();
        // Include id in data passed to select, so it can be renamed/transformed
        const dataWithId = { id: docSnap.id, ...rawData };
        const data = select ? select(dataWithId) : dataWithId;
        return data as WithId<T>;
      });
    },
    enabled: enabled && !subscribe,
    staleTime: subscribe ? Infinity : staleTime,
    gcTime,
  });
}


================================================================================
FILE PATH: packages/query-core/src/firestore/use-firestore-doc.ts
================================================================================
'use client';

import { useEffect } from 'react';
import { useQuery, useQueryClient, type UseQueryResult } from '@tanstack/react-query';
import { doc, getDoc, onSnapshot, type DocumentData } from 'firebase/firestore';
import { useFirestoreDb } from './context';
import type { FirestoreDocOptions, WithId } from './types';

/**
 * Fetch a single Firestore document with optional realtime updates.
 * 
 * @example
 * ```tsx
 * // Simple fetch
 * const { data: user } = useFirestoreDoc<User>({
 *   docPath: `users/${userId}`,
 *   queryKey: ['user', userId],
 * });
 * 
 * // With realtime updates
 * const { data: project } = useFirestoreDoc<Project>({
 *   docPath: `projects/${projectId}`,
 *   queryKey: ['project', projectId],
 *   subscribe: true,
 * });
 * 
 * // Conditional fetch
 * const { data: profile } = useFirestoreDoc<Profile>({
 *   docPath: `profiles/${userId}`,
 *   queryKey: ['profile', userId],
 *   enabled: !!userId,
 * });
 * ```
 */
export function useFirestoreDoc<T extends DocumentData = DocumentData>({
  docPath,
  queryKey,
  enabled = true,
  subscribe = false,
  staleTime,
  gcTime,
  select,
}: FirestoreDocOptions<T>): UseQueryResult<WithId<T> | null, Error> {
  const db = useFirestoreDb();
  const queryClient = useQueryClient();

  // Set up realtime subscription
  useEffect(() => {
    if (!subscribe || !enabled) return;

    const docRef = doc(db, docPath);
    const unsubscribe = onSnapshot(
      docRef,
      (snapshot) => {
        if (snapshot.exists()) {
          const rawData = snapshot.data();
          // Include id in data passed to select, so it can be renamed/transformed
          const dataWithId = { id: snapshot.id, ...rawData };
          const data = select ? select(dataWithId) : dataWithId;
          queryClient.setQueryData(queryKey, data as WithId<T>);
        } else {
          queryClient.setQueryData(queryKey, null);
        }
      },
      (error) => {
        console.error('[useFirestoreDoc] Subscription error:', error);
      }
    );

    return () => unsubscribe();
  }, [db, docPath, queryKey, enabled, subscribe, select, queryClient]);

  return useQuery({
    queryKey,
    queryFn: async (): Promise<WithId<T> | null> => {
      const docRef = doc(db, docPath);
      const snapshot = await getDoc(docRef);

      if (!snapshot.exists()) {
        return null;
      }

      const rawData = snapshot.data();
      // Include id in data passed to select, so it can be renamed/transformed
      const dataWithId = { id: snapshot.id, ...rawData };
      const data = select ? select(dataWithId) : dataWithId;
      return data as WithId<T>;
    },
    enabled: enabled && !subscribe, // Don't fetch if subscribing (snapshot handles it)
    staleTime: subscribe ? Infinity : staleTime, // Realtime data is always fresh
    gcTime,
  });
}


================================================================================
FILE PATH: packages/query-core/src/firestore/use-firestore-infinite.ts
================================================================================
'use client';

import { useInfiniteQuery, type UseInfiniteQueryResult } from '@tanstack/react-query';
import {
  collection,
  query,
  getDocs,
  limit,
  startAfter,
  type DocumentData,
  type DocumentSnapshot,
} from 'firebase/firestore';
import { useFirestoreDb } from './context';
import type { FirestoreInfiniteOptions, InfinitePage, WithId } from './types';

const DEFAULT_PAGE_SIZE = 20;

/**
 * Infinite scroll pagination for Firestore collections.
 * Automatically handles cursor-based pagination with React Query.
 * 
 * @example
 * ```tsx
 * const {
 *   data,
 *   fetchNextPage,
 *   hasNextPage,
 *   isFetchingNextPage,
 *   isLoading,
 * } = useFirestoreInfinite<Post>({
 *   collectionPath: 'posts',
 *   queryKey: ['posts', 'feed'],
 *   constraints: [
 *     where('status', '==', 'published'),
 *     orderBy('createdAt', 'desc'),
 *   ],
 *   pageSize: 20,
 * });
 * 
 * // Flatten pages for rendering
 * const posts = data?.pages.flatMap(page => page.items) ?? [];
 * 
 * // Load more on scroll
 * <InfiniteScroll onLoadMore={fetchNextPage} hasMore={hasNextPage} />
 * ```
 */
export function useFirestoreInfinite<T extends DocumentData = DocumentData>({
  collectionPath,
  queryKey,
  constraints = [],
  pageSize = DEFAULT_PAGE_SIZE,
  enabled = true,
  staleTime,
  gcTime,
  select,
}: FirestoreInfiniteOptions<T>): UseInfiniteQueryResult<{ pages: InfinitePage<T>[]; pageParams: (DocumentSnapshot | null)[] }, Error> {
  const db = useFirestoreDb();

  return useInfiniteQuery({
    queryKey,
    queryFn: async ({ pageParam }): Promise<InfinitePage<T>> => {
      const collectionRef = collection(db, collectionPath);
      
      // Build query with constraints
      const queryConstraints = [
        ...constraints,
        ...(pageParam ? [startAfter(pageParam as DocumentSnapshot)] : []),
        limit(pageSize),
      ];

      const q = query(collectionRef, ...queryConstraints);
      const snapshot = await getDocs(q);

      const items = snapshot.docs.map((docSnap) => {
        const rawData = docSnap.data();
        // Include id in data passed to select, so it can be renamed/transformed
        const dataWithId = { id: docSnap.id, ...rawData };
        const data = select ? select(dataWithId) : dataWithId;
        return data as WithId<T>;
      });

      return {
        items,
        lastDoc: snapshot.docs[snapshot.docs.length - 1] ?? null,
        size: snapshot.docs.length,
      };
    },
    initialPageParam: null as DocumentSnapshot | null,
    getNextPageParam: (lastPage) => {
      // If we got fewer items than requested, there are no more pages
      if (lastPage.size < pageSize) return undefined;
      return lastPage.lastDoc;
    },
    enabled,
    staleTime,
    gcTime,
  });
}

/**
 * Helper to flatten infinite query pages into a single array.
 * 
 * @example
 * ```tsx
 * const { data } = useFirestoreInfinite<Post>({ ... });
 * const posts = flattenInfiniteData(data);
 * ```
 */
export function flattenInfiniteData<T>(
  data: { pages: InfinitePage<T>[] } | undefined
): WithId<T>[] {
  if (!data) return [];
  return data.pages.flatMap((page) => page.items);
}

/**
 * Get total count of items across all loaded pages.
 */
export function getInfiniteDataCount<T>(
  data: { pages: InfinitePage<T>[] } | undefined
): number {
  if (!data) return 0;
  return data.pages.reduce((sum, page) => sum + page.items.length, 0);
}


================================================================================
FILE PATH: packages/query-core/src/firestore/use-firestore-mutations.ts
================================================================================
'use client';

import { useMutation, useQueryClient, type QueryKey, type UseMutationResult } from '@tanstack/react-query';
import {
  doc,
  setDoc,
  updateDoc,
  deleteDoc,
  writeBatch,
  type DocumentData,
} from 'firebase/firestore';
import { useFirestoreDb } from './context';
import type { FirestoreMutationOptions, FirestoreBatchOptions, MutationOperation } from './types';

const DEFAULT_BATCH_SIZE = 450;

interface SetResult<T> {
  id: string;
  data: T;
}

export function useFirestoreSet<T extends DocumentData>({
  invalidateKeys = [],
}: Pick<FirestoreMutationOptions<T>, 'invalidateKeys'> = {}): UseMutationResult<
  SetResult<T>,
  Error,
  { docPath: string; data: T; merge?: boolean }
> {
  const db = useFirestoreDb();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      docPath,
      data,
      merge = false,
    }: {
      docPath: string;
      data: T;
      merge?: boolean;
    }) => {
      const docRef = doc(db, docPath);
      await setDoc(docRef, data, { merge });
      return { id: docRef.id, data };
    },
    onSuccess: () => {
      invalidateKeys.forEach((key) => {
        queryClient.invalidateQueries({ queryKey: key });
      });
    },
  });
}

export function useFirestoreUpdate<T extends DocumentData>({
  invalidateKeys = [],
  optimistic,
}: FirestoreMutationOptions<T> = {}): UseMutationResult<
  Partial<T>,
  Error,
  { docPath: string; data: Partial<T> },
  { previousData: T | undefined } | undefined
> {
  const db = useFirestoreDb();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      docPath,
      data,
    }: {
      docPath: string;
      data: Partial<T>;
    }) => {
      const docRef = doc(db, docPath);
      await updateDoc(docRef, data as DocumentData);
      return data;
    },
    onMutate: async ({ data }) => {
      if (!optimistic) return undefined;

      await queryClient.cancelQueries({ queryKey: optimistic.queryKey });
      const previousData = queryClient.getQueryData<T>(optimistic.queryKey);

      queryClient.setQueryData<T>(optimistic.queryKey, (old) =>
        optimistic.updater(old, data as Partial<T>)
      );

      return { previousData };
    },
    onError: (_error, _variables, context) => {
      if (optimistic && context?.previousData !== undefined) {
        queryClient.setQueryData(optimistic.queryKey, context.previousData);
      }
    },
    onSettled: () => {
      invalidateKeys.forEach((key) => {
        queryClient.invalidateQueries({ queryKey: key });
      });
      if (optimistic) {
        queryClient.invalidateQueries({ queryKey: optimistic.queryKey });
      }
    },
  });
}

export function useFirestoreDelete<T = unknown>({
  invalidateKeys = [],
  optimistic,
}: {
  invalidateKeys?: readonly QueryKey[];
  optimistic?: {
    queryKey: QueryKey;
    updater: (oldData: T | undefined, docPath: string) => T;
  };
} = {}): UseMutationResult<
  string,
  Error,
  { docPath: string },
  { previousData: T | undefined } | undefined
> {
  const db = useFirestoreDb();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ docPath }: { docPath: string }) => {
      const docRef = doc(db, docPath);
      await deleteDoc(docRef);
      return docPath;
    },
    onMutate: async ({ docPath }) => {
      if (!optimistic) return undefined;

      await queryClient.cancelQueries({ queryKey: optimistic.queryKey });
      const previousData = queryClient.getQueryData<T>(optimistic.queryKey);

      queryClient.setQueryData<T>(optimistic.queryKey, (old) =>
        optimistic.updater(old, docPath)
      );

      return { previousData };
    },
    onError: (_error, _variables, context) => {
      if (optimistic && context?.previousData !== undefined) {
        queryClient.setQueryData(optimistic.queryKey, context.previousData);
      }
    },
    onSettled: () => {
      invalidateKeys.forEach((key) => {
        queryClient.invalidateQueries({ queryKey: key });
      });
      if (optimistic) {
        queryClient.invalidateQueries({ queryKey: optimistic.queryKey });
      }
    },
  });
}

interface BatchResult {
  committed: number;
  batches: number;
}

export function useFirestoreBatch({
  invalidateKeys = [],
  batchSize = DEFAULT_BATCH_SIZE,
}: FirestoreBatchOptions = {}): UseMutationResult<
  BatchResult,
  Error,
  { operations: MutationOperation[] }
> {
  const db = useFirestoreDb();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      operations,
    }: {
      operations: MutationOperation[];
    }) => {
      const chunks: MutationOperation[][] = [];
      for (let i = 0; i < operations.length; i += batchSize) {
        chunks.push(operations.slice(i, i + batchSize));
      }

      let totalCommitted = 0;

      for (const chunk of chunks) {
        const batch = writeBatch(db);

        for (const op of chunk) {
          const docRef = doc(db, op.docPath);

          switch (op.type) {
            case 'set':
              if (op.merge) {
                batch.set(docRef, op.data, { merge: true });
              } else {
                batch.set(docRef, op.data);
              }
              break;
            case 'update':
              batch.update(docRef, op.data);
              break;
            case 'delete':
              batch.delete(docRef);
              break;
          }
        }

        await batch.commit();
        totalCommitted += chunk.length;
      }

      return {
        committed: totalCommitted,
        batches: chunks.length,
      };
    },
    onSuccess: () => {
      invalidateKeys.forEach((key) => {
        queryClient.invalidateQueries({ queryKey: key });
      });
    },
  });
}

================================================================================
FILE PATH: packages/query-core/src/firestore/use-firestore-paginated.ts
================================================================================
'use client';

import { useState, useCallback, useMemo } from 'react';
import { useQuery, useQueryClient, type UseQueryResult } from '@tanstack/react-query';
import {
  collection,
  query,
  getDocs,
  limit,
  startAfter,
  type DocumentData,
  type DocumentSnapshot,
} from 'firebase/firestore';
import { useFirestoreDb } from './context';
import type { FirestorePaginatedOptions, WithId } from './types';

const DEFAULT_PAGE_SIZE = 10;

/**
 * Return type for useFirestorePaginated hook
 */
export type UseFirestorePaginatedResult<T> = UseQueryResult<WithId<T>[], Error> & {
  page: number;
  pageSize: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
  setPage: (page: number) => void;
  nextPage: () => void;
  prevPage: () => void;
  resetToFirstPage: () => void;
};

/**
 * Page-based pagination for Firestore collections.
 * Supports navigating to specific pages (1, 2, 3...) rather than infinite scroll.
 * 
 * @example
 * ```tsx
 * const {
 *   data,
 *   page,
 *   setPage,
 *   hasNextPage,
 *   hasPrevPage,
 *   isLoading,
 * } = useFirestorePaginated<Task>({
 *   collectionPath: 'tasks',
 *   queryKey: ['tasks', 'list'],
 *   constraints: [where('status', '==', 'active'), orderBy('createdAt', 'desc')],
 *   pageSize: 10,
 * });
 * 
 * // Render pagination controls
 * <button onClick={() => setPage(page - 1)} disabled={!hasPrevPage}>Previous</button>
 * <span>Page {page}</span>
 * <button onClick={() => setPage(page + 1)} disabled={!hasNextPage}>Next</button>
 * ```
 */
export function useFirestorePaginated<T extends DocumentData = DocumentData>({
  collectionPath,
  queryKey,
  constraints = [],
  pageSize = DEFAULT_PAGE_SIZE,
  initialPage = 1,
  enabled = true,
  staleTime,
  gcTime,
  select,
}: FirestorePaginatedOptions<T>): UseFirestorePaginatedResult<T> {
  const db = useFirestoreDb();
  const queryClient = useQueryClient();
  
  const [page, setPageInternal] = useState(initialPage);
  const [cursors, setCursors] = useState<Map<number, DocumentSnapshot>>(new Map());
  const [hasMore, setHasMore] = useState(true);

  // Create a stable query key that includes the page
  const pageQueryKey = useMemo(
    () => [...queryKey, 'page', page],
    [queryKey, page]
  );

  const queryResult = useQuery({
    queryKey: pageQueryKey,
    queryFn: async (): Promise<WithId<T>[]> => {
      const collectionRef = collection(db, collectionPath);
      
      // Get cursor for current page (if not page 1)
      const cursor = page > 1 ? cursors.get(page - 1) : undefined;
      
      // Build query
      const queryConstraints = [
        ...constraints,
        ...(cursor ? [startAfter(cursor)] : []),
        limit(pageSize),
      ];

      const q = query(collectionRef, ...queryConstraints);
      const snapshot = await getDocs(q);

      // Store the last doc as cursor for next page
      if (snapshot.docs.length > 0) {
        const lastDoc = snapshot.docs[snapshot.docs.length - 1];
        setCursors((prev) => {
          const next = new Map(prev);
          next.set(page, lastDoc);
          return next;
        });
      }

      // Determine if there are more pages
      setHasMore(snapshot.docs.length === pageSize);

      return snapshot.docs.map((docSnap) => {
        const rawData = docSnap.data();
        // Include id in data passed to select, so it can be renamed/transformed
        const dataWithId = { id: docSnap.id, ...rawData };
        const data = select ? select(dataWithId) : dataWithId;
        return data as WithId<T>;
      });
    },
    enabled,
    staleTime,
    gcTime,
  });

  const setPage = useCallback((newPage: number) => {
    if (newPage < 1) return;
    
    // Can only go forward one page at a time if cursor doesn't exist
    if (newPage > page + 1 && !cursors.has(newPage - 1)) {
      console.warn('[useFirestorePaginated] Cannot skip pages. Navigate sequentially.');
      return;
    }
    
    setPageInternal(newPage);
  }, [page, cursors]);

  const nextPage = useCallback(() => {
    if (hasMore) setPage(page + 1);
  }, [page, hasMore, setPage]);

  const prevPage = useCallback(() => {
    if (page > 1) setPage(page - 1);
  }, [page, setPage]);

  const resetToFirstPage = useCallback(() => {
    setCursors(new Map());
    setPageInternal(1);
    setHasMore(true);
    // Invalidate all cached pages
    queryClient.invalidateQueries({ queryKey, exact: false });
  }, [queryClient, queryKey]);

  return {
    ...queryResult,
    // Pagination state
    page,
    pageSize,
    hasNextPage: hasMore,
    hasPrevPage: page > 1,
    // Navigation functions
    setPage,
    nextPage,
    prevPage,
    resetToFirstPage,
  };
}


================================================================================
FILE PATH: packages/query-core/src/index.ts
================================================================================
// Query Client
export { createTTTQueryClient } from './query-client';
export type { CreateTTTQueryClientOptions } from './query-client';

// Query Keys
export { keys, createKeyScope } from './keys';
export type { QueryKey } from './keys';

// Cache Helpers
export { invalidateByPrefix, removeByPrefix, updateQueryData } from './cache-helpers';

// Provider
export { TTTQueryProvider } from './provider';
export type { TTTQueryProviderProps } from './provider';

// Firestore Integration
export {
  // Provider
  FirestoreProvider,
  useFirestoreDb,
  // Query Hooks
  useFirestoreDoc,
  useFirestoreCollection,
  useFirestoreInfinite,
  useFirestorePaginated,
  // Mutation Hooks
  useFirestoreSet,
  useFirestoreUpdate,
  useFirestoreDelete,
  useFirestoreBatch,
  // Helpers
  flattenInfiniteData,
  getInfiniteDataCount,
  docWithId,
} from './firestore';

export type {
  // Provider
  FirestoreProviderProps,
  // Types
  WithId,
  FirestoreBaseOptions,
  FirestoreDocOptions,
  FirestoreCollectionOptions,
  FirestoreInfiniteOptions,
  FirestorePaginatedOptions,
  InfinitePage,
  PaginatedResult,
  MutationOperation,
  FirestoreMutationOptions,
  FirestoreBatchOptions,
} from './firestore';


================================================================================
FILE PATH: packages/query-core/src/keys.ts
================================================================================
/**
 * Lightweight, stable query key helpers.
 *
 * Convention:
 * - `keys.user.all` => ['user']
 * - `keys.user.detail(id)` => ['user', 'detail', id]
 * - `keys.user.list(filters?)` => ['user', 'list', filters]
 * - `keys.user.custom('accountStatus', id)` => ['user', 'accountStatus', id]
 */

type KeyPart = string | number | boolean | null | undefined | Record<string, unknown>;
export type QueryKey = readonly unknown[];

function withScope(scope: string, ...parts: KeyPart[]): QueryKey {
  const cleaned = parts.filter((p) => p !== undefined);
  return [scope, ...cleaned] as const;
}

export const keys = {
  user: {
    all: withScope('user'),
    detail: (id: string) => withScope('user', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('user', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('user', ...parts),
  },
  follows: {
    all: withScope('follows'),
    detail: (id: string) => withScope('follows', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('follows', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('follows', ...parts),
  },
  skills: {
    all: withScope('skills'),
    detail: (id: string) => withScope('skills', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('skills', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('skills', ...parts),
  },
  projects: {
    all: withScope('projects'),
    detail: (id: string) => withScope('projects', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('projects', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('projects', ...parts),
  },
  messages: {
    all: withScope('messages'),
    detail: (id: string) => withScope('messages', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('messages', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('messages', ...parts),
  },
  library: {
    all: withScope('library'),
    detail: (id: string) => withScope('library', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('library', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('library', ...parts),
  },
  admin: {
    all: withScope('admin'),
    detail: (id: string) => withScope('admin', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('admin', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('admin', ...parts),
  },
  opportunities: {
    all: withScope('opportunities'),
    detail: (id: string) => withScope('opportunities', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('opportunities', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('opportunities', ...parts),
  },
  jobs: {
    all: withScope('jobs'),
    detail: (id: string) => withScope('jobs', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('jobs', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('jobs', ...parts),
  },
  donations: {
    all: withScope('donations'),
    detail: (id: string) => withScope('donations', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('donations', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('donations', ...parts),
  },
  futurePlans: {
    all: withScope('futurePlans'),
    detail: (id: string) => withScope('futurePlans', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('futurePlans', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('futurePlans', ...parts),
  },
  rulesAndAgreements: {
    all: withScope('rulesAndAgreements'),
    detail: (id: string) => withScope('rulesAndAgreements', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('rulesAndAgreements', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('rulesAndAgreements', ...parts),
  },
  chat: {
    all: withScope('chat'),
    detail: (id: string) => withScope('chat', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('chat', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('chat', ...parts),
  },
  notifications: {
    all: withScope('notifications'),
    detail: (id: string) => withScope('notifications', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('notifications', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('notifications', ...parts),
  },
  shortLinks: {
    all: withScope('shortLinks'),
    detail: (id: string) => withScope('shortLinks', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('shortLinks', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('shortLinks', ...parts),
  },
  mentions: {
    all: withScope('mentions'),
    detail: (id: string) => withScope('mentions', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('mentions', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('mentions', ...parts),
  },
  violations: {
    all: withScope('violations'),
    detail: (id: string) => withScope('violations', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('violations', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('violations', ...parts),
  },
  feedback: {
    all: withScope('feedback'),
    detail: (id: string) => withScope('feedback', 'detail', id),
    list: (params?: Record<string, unknown>) => withScope('feedback', 'list', params),
    custom: (...parts: KeyPart[]) => withScope('feedback', ...parts),
  },
} as const;

/**
 * Utility for apps that want to define their own scoped key sets
 * while following the same conventions.
 */
export function createKeyScope(scope: string) {
  return {
    all: withScope(scope),
    detail: (id: string) => withScope(scope, 'detail', id),
    list: (params?: Record<string, unknown>) => withScope(scope, 'list', params),
    custom: (...parts: KeyPart[]) => withScope(scope, ...parts),
  } as const;
}

================================================================================
FILE PATH: packages/query-core/src/provider.tsx
================================================================================
'use client';

import React from 'react';
import { QueryClientProvider } from '@tanstack/react-query';
import { createTTTQueryClient, type CreateTTTQueryClientOptions } from './query-client';

export type TTTQueryProviderProps = React.PropsWithChildren<{
  /** Optional overrides applied when the client is first created. */
  clientOptions?: CreateTTTQueryClientOptions;
}>;

/**
 * Client component wrapper for Next.js / React apps.
 * Creates a single QueryClient per browser session.
 */
export function TTTQueryProvider({ children, clientOptions }: TTTQueryProviderProps) {
  const [client] = React.useState(() => createTTTQueryClient(clientOptions));
  return <QueryClientProvider client={client}>{children}</QueryClientProvider>;
}


================================================================================
FILE PATH: packages/query-core/src/query-client.ts
================================================================================
import { QueryClient, type QueryClientConfig } from '@tanstack/react-query';
import { tttQueryClientConfig } from './defaults';

export type CreateTTTQueryClientOptions = QueryClientConfig;

/**
 * Factory so every app uses the same baseline behavior.
 * Pass overrides to adjust defaults without forking.
 */
export function createTTTQueryClient(overrides: CreateTTTQueryClientOptions = {}) {
  return new QueryClient({
    ...tttQueryClientConfig,
    ...overrides,
    defaultOptions: {
      ...tttQueryClientConfig.defaultOptions,
      ...overrides.defaultOptions,
      queries: {
        ...tttQueryClientConfig.defaultOptions?.queries,
        ...overrides.defaultOptions?.queries,
      },
      mutations: {
        ...tttQueryClientConfig.defaultOptions?.mutations,
        ...overrides.defaultOptions?.mutations,
      },
    },
  });
}


================================================================================
FILE PATH: packages/query-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "composite": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.test.tsx"]
}


================================================================================
FILE PATH: packages/theme-core/package.json
================================================================================
{
    "name": "@ttt-productions/theme-core",
    "version": "0.2.3",
    "description": "Theme provider + CSS token contract for TTT Productions apps",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/theme-core"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": [
        "**/*.css"
    ],
    "files": [
        "dist"
    ],
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "default": "./dist/index.js"
        },
        "./styles.css": "./dist/styles/index.css",
        "./components.css": "./dist/styles/components.css"
    },
    "scripts": {
        "build": "tsc && rm -rf dist/styles && mkdir -p dist/styles && cp -R src/styles/* dist/styles/",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
        "react": ">=19.0.0",
        "react-dom": ">=19.0.0"
    },
    "dependencies": {
        "next-themes": "^0.4.6"
    },
    "devDependencies": {
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/theme-core/README.md
================================================================================
# @ttt-productions/theme-core

Theme provider + CSS token contract for TTT Productions apps.

## Install
```bash
npm install @ttt-productions/theme-core


================================================================================
FILE PATH: packages/theme-core/src/index.ts
================================================================================
export * from "./theme-provider";
export * from "./required-tokens";


================================================================================
FILE PATH: packages/theme-core/src/required-tokens.ts
================================================================================
export const REQUIRED_TOKENS = [
  "--brand-primary",
  "--brand-secondary",
  "--brand-accent",
] as const;

export type RequiredToken = (typeof REQUIRED_TOKENS)[number];


================================================================================
FILE PATH: packages/theme-core/src/styles/base.css
================================================================================
html, body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}

* {
  border-color: hsl(var(--border));
}

================================================================================
FILE PATH: packages/theme-core/src/styles/components.css
================================================================================

/* =========================================================
    FOUNDATIONS (icon + layout bundles) — replaces inline utils
    ========================================================= */

/* Icons */
.icon-xxs { height: 0.75rem; width: 0.75rem; }
.icon-xs  { height: 1rem; width: 1rem; }
.icon-sm  { height: 1.25rem; width: 1.25rem; }
.icon-md  { height: 1.5rem; width: 1.5rem; }
.icon-lg  { height: 2rem; width: 2rem; }
.icon-xl  { height: 2.5rem; width: 2.5rem; }
.icon-2xl { height: 3rem; width: 3rem; }

/* Spinners */
.spinner-xs { 
  height: 1rem; 
  width: 1rem; 
  animation: spin 1s linear infinite; 
  color: hsl(var(--primary)); 
}
.spinner-sm { 
  height: 1.25rem; 
  width: 1.25rem; 
  animation: spin 1s linear infinite; 
  color: hsl(var(--primary)); 
}
.spinner-md { 
  height: 1.5rem; 
  width: 1.5rem; 
  animation: spin 1s linear infinite; 
  color: hsl(var(--primary)); 
}
.spinner-lg { 
  height: 2rem; 
  width: 2rem; 
  animation: spin 1s linear infinite; 
  color: hsl(var(--primary)); 
}
.spinner-xl { 
  height: 2.5rem; 
  width: 2.5rem; 
  animation: spin 1s linear infinite; 
  color: hsl(var(--primary)); 
}
.spinner-with-gap { margin-right: 0.5rem; }

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* Common centering */
.center-row { 
  display: flex; 
  align-items: center; 
  justify-content: center; 
}
.center-col { 
  display: flex; 
  flex-direction: column; 
  align-items: center; 
  justify-content: center; 
}
.loading-block { 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  padding-top: 2rem; 
  padding-bottom: 2rem; 
}
.loading-block-padded { 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  padding: 2rem; 
}
.loading-screen { 
  display: flex; 
  flex-direction: column; 
  height: 100vh;
  height: calc(var(--vh, 1vh) * 100);
  width: 100vw; 
  align-items: center; 
  justify-content: center; 
  background-color: hsl(var(--background)); 
}
.loading-screen > * + * {
  margin-top: 1rem;
}

/* Stacks */
.stack-1 > * + * { margin-top: 0.25rem; }
.stack-2 > * + * { margin-top: 0.5rem; }
.stack-4 > * + * { margin-top: 1rem; }
.stack-6 > * + * { margin-top: 1.5rem; }

/* =========================================================
    PAGE LAYOUT
    ========================================================= */
.page-container {
  flex: 1 1 0%;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  padding-top: 1rem;
  padding-bottom: 1rem;
}

.page-card {
  width: 100%;
  background-color: hsl(var(--card));
  color: hsl(var(--card-foreground));
  box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  border-radius: 0.5rem;
  border-width: 2px;
  border-color: hsl(var(--border));
}

.page-card-header {
  text-align: center;
  padding: 1rem;
  align-items: center;
}
@media (min-width: 640px) {
  .page-card-header {
    padding: 1.5rem;
  }
}

.page-card-header-left {
  padding: 1rem;
  text-align: left;
}
@media (min-width: 640px) {
  .page-card-header-left {
    padding: 1.5rem;
  }
}

.page-card-title {
  font-size: 1.875rem;
  line-height: 2.25rem;
  font-weight: 700;
  color: hsl(var(--foreground));
}

.page-card-content {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
  padding-bottom: 1rem;
}
@media (min-width: 640px) {
  .page-card-content {
    padding-left: 1.5rem;
    padding-right: 1.5rem;
  }
}

.inner-card-container {
  padding-left: 1rem;
  padding-right: 1rem;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

/* =========================================================
    TYPOGRAPHY (high-level)
    ========================================================= */
.text-body {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 500;
  color: hsl(var(--foreground));
}

.text-muted {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 500;
  color: hsl(var(--muted-foreground));
}

.text-caption {
  font-size: 0.75rem;
  line-height: 1rem;
  font-weight: 500;
  color: hsl(var(--muted-foreground));
}

.text-small {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 700;
  color: hsl(var(--foreground));
}

.text-xs-bold {
  font-size: 0.75rem;
  line-height: 1rem;
  font-weight: 700;
  color: hsl(var(--foreground));
}

.text-label {
  font-weight: 700;
  color: hsl(var(--foreground));
}

.text-counter {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

.empty-state-text {
  text-align: center;
  padding-top: 2rem;
  padding-bottom: 2rem;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

.card-description {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

.input-description {
  font-size: 0.75rem;
  line-height: 1rem;
  color: hsl(var(--muted-foreground));
}

.disclaimer-text {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 700;
  text-align: center;
  color: hsl(var(--muted-foreground));
}

/* Error blocks / inline */
.text-error {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 700;
  color: hsl(var(--destructive));
}

.text-error-block {
  text-align: center;
  padding: 1rem;
  font-weight: 700;
  border-radius: 0.375rem;
  border-width: 1px;
  color: hsl(var(--destructive));
  border-color: hsl(var(--destructive) / 0.5);
  background-color: hsl(var(--destructive) / 0.10);
}

/* =========================================================
    LINKS
    ========================================================= */
.auth-link {
  font-size: 0.875rem;
  line-height: 1.25rem;
  text-decoration: underline;
  font-weight: 600;
  color: hsl(var(--primary));
}

/* =========================================================
    CHAT
    ========================================================= */
.chat-date-separator {
  font-size: 0.75rem;
  line-height: 1rem;
  font-weight: 700;
  background-color: hsl(var(--muted));
  padding-left: 0.75rem;
  padding-right: 0.75rem;
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
  border-radius: 9999px;
  color: hsl(var(--foreground));
}

/* Status pills (replaces bg-blue-100/text-blue-700 etc.) */
.status-pill {
  font-size: 0.75rem;
  line-height: 1rem;
  font-weight: 700;
  color: hsl(var(--foreground));
  padding-left: 0.5rem;
  padding-right: 0.5rem;
  padding-top: 0.125rem;
  padding-bottom: 0.125rem;
  border-radius: 9999px;
  display: inline-flex;
  align-items: center;
}

.status-pill--info {
  background-color: hsl(var(--info) / 0.15);
  color: hsl(var(--info));
}

.status-pill--success {
  background-color: hsl(var(--success) / 0.15);
  color: hsl(var(--success));
}

.status-pill--warning {
  background-color: hsl(var(--warning) / 0.15);
  color: hsl(var(--warning));
}

.status-pill--muted {
  background-color: hsl(var(--muted));
  color: hsl(var(--muted-foreground));
}

/* High contrast pills: pure B/W */
.high-contrast .status-pill--info,
.high-contrast .status-pill--success,
.high-contrast .status-pill--warning,
.high-contrast .status-pill--muted {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
  border: 2px solid hsl(var(--border));
}

/* ===================
  SCREEN ADAPTIVE VIEW
=================== */
.screen-adaptive-root {
  display: flex;
  flex: 1 1 0%;
  flex-direction: column;
  width: 100%;
}

.screen-adaptive-inner {
  margin-left: auto;
  margin-right: auto;
  width: 100%;
}

/* Max width variants */
.screen-max-w-none { max-width: none; }
.screen-max-w-full { max-width: 100%; }

.screen-max-w-sm  { max-width: 24rem; }  /* 384px */
.screen-max-w-md  { max-width: 28rem; }  /* 448px */
.screen-max-w-lg  { max-width: 32rem; }  /* 512px */
.screen-max-w-xl  { max-width: 36rem; }  /* 576px */

.screen-max-w-2xl { max-width: 42rem; }  /* 672px */
.screen-max-w-3xl { max-width: 48rem; }  /* 768px */
.screen-max-w-4xl { max-width: 56rem; }  /* 896px */
.screen-max-w-5xl { max-width: 64rem; }  /* 1024px */
.screen-max-w-6xl { max-width: 72rem; }  /* 1152px */
.screen-max-w-7xl { max-width: 80rem; }  /* 1280px */

/* =========================================================
    RULE CARDS
    ========================================================= */
.rule-card {
  padding: 1rem;
  border-radius: 0.5rem;
  border-width: 2px;
  border-color: hsl(var(--border));
  background-color: hsl(var(--card));
}

.rule-card-title {
  font-weight: 700;
  margin-bottom: 0.5rem;
  color: hsl(var(--foreground));
}

.rule-card-description {
  font-size: 0.875rem;
  line-height: 1.625;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

/* =========================================================
    ACCORDION
    ========================================================= */
.accordion-trigger {
  padding: 1.5rem;
  border-radius: 0.5rem 0.5rem 0 0;
}
.accordion-trigger:hover {
  text-decoration: none;
}

.accordion-icon-container {
  padding: 0.5rem;
  border-radius: 0.5rem;
  background-color: hsl(var(--primary) / 0.10);
  color: hsl(var(--primary));
}

.accordion-title {
  font-size: 1.125rem;
  line-height: 1.75rem;
  font-weight: 600;
  color: hsl(var(--foreground));
}

.accordion-content-container {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
  padding-top: 1rem;
  padding-bottom: 1rem;
  border-radius: 0 0 0.5rem 0.5rem;
  background-color: hsl(var(--card));
}
.accordion-content-container > * + * {
  margin-top: 1rem;
}

/* =========================================================
    DETAILS (nested accordions)
    ========================================================= */
.details-summary {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  list-style: none;
  padding: 1rem;
  border-radius: 0.5rem;
  border-width: 2px;
  border-color: hsl(var(--border));
  background-color: hsl(var(--card));
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.details-summary:hover {
  border-color: hsl(var(--primary));
  background-color: hsl(var(--primary) / 0.05);
}

.details-icon-container {
  padding: 0.5rem;
  border-radius: 0.5rem;
  transition-property: color, background-color;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
  background-color: hsl(var(--primary) / 0.10);
  color: hsl(var(--primary));
}

.group\/details:hover .details-icon-container {
  background-color: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
}

.details-title {
  font-weight: 600;
  font-size: 1rem;
  line-height: 1.5rem;
  color: hsl(var(--foreground));
}

.details-chevron {
  color: hsl(var(--primary));
}

/* =========================================================
    AGREEMENT LIST ITEMS
    ========================================================= */
.agreement-list-item {
  display: flex;
  gap: 0.5rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

/* =========================================================
    FUTURE PLANS / MEDIA
    ========================================================= */
.future-plan-description {
  font-size: 1rem;
  line-height: 1.5rem;
  white-space: pre-wrap;
  line-height: 1.625;
  max-width: 65ch;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

.future-plan-media {
  width: 100%;
  aspect-ratio: 16 / 9;
  border-radius: 0.5rem;
  overflow: hidden;
  border-width: 1px;
  border-color: hsl(var(--border));
  background-color: hsl(var(--muted));
}

/* Media helpers (replaces repeated w/full/max-w/aspect) */
.media-image-sm-centered {
  width: 100%;
  height: auto;
  max-width: 24rem;
  margin-left: auto;
  margin-right: auto;
}

.media-square-centered {
  width: 100%;
  max-width: 400px;
  margin-left: auto;
  margin-right: auto;
  aspect-ratio: 1 / 1;
  border-radius: 0.375rem;
  overflow: hidden;
  background-color: hsl(var(--muted));
}

.media-wide {
  width: 100%;
  aspect-ratio: 16 / 9;
  border-radius: 0.5rem;
  overflow: hidden;
  border-width: 1px;
  border-color: hsl(var(--border));
  background-color: hsl(var(--muted));
}

/* =========================================================
    INFO SECTIONS
    ========================================================= */
.info-section {
  display: flex;
  align-items: flex-start;
  gap: 1rem;
}

.info-section-icon {
  margin-top: 0.25rem;
  color: hsl(var(--primary));
}

.info-section-title {
  font-weight: 600;
  color: hsl(var(--foreground));
}

.info-section-description {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

.info-section-divider {
  width: 100%;
  height: 1px;
  background-color: hsl(var(--border));
}

.info-section-header {
  font-size: 1.125rem;
  line-height: 1.75rem;
  font-weight: 600;
  text-align: center;
  padding-top: 1rem;
  color: hsl(var(--foreground));
}

/* =========================================================
    ATTRIBUTION SECTIONS
    ========================================================= */
.attribution-item {
  display: flex;
  align-items: flex-start;
  gap: 1rem;
}

.attribution-icon {
  margin-top: 0.25rem;
  color: hsl(var(--primary));
}

.attribution-title {
  font-weight: 600;
  color: hsl(var(--foreground));
}

.attribution-cost {
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 600;
  color: hsl(var(--primary));
}

.attribution-description {
  font-size: 0.875rem;
  line-height: 1.25rem;
  margin-top: 0.25rem;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

/* =========================================================
    DEDICATION SECTIONS
    ========================================================= */
.dedication-section {
  text-align: center;
}
.dedication-section > * + * {
  margin-top: 0.5rem;
}

.dedication-header {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.dedication-title {
  font-weight: 600;
  font-size: 1.125rem;
  line-height: 1.75rem;
  color: hsl(var(--foreground));
}

.dedication-content {
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

/* =========================================================
    DMCA INFO
    ========================================================= */
.dmca-section-title {
  font-size: 1.125rem;
  line-height: 1.75rem;
  font-weight: 600;
  color: hsl(var(--foreground));
}

.dmca-info-container {
  padding-left: 1rem;
  border-left-width: 2px;
  border-color: hsl(var(--border));
}
.dmca-info-container > * + * {
  margin-top: 0.5rem;
}

.dmca-info-row {
  display: flex;
  flex-direction: column;
}
@media (min-width: 640px) {
  .dmca-info-row {
    flex-direction: row;
    align-items: center;
  }
}

.dmca-label {
  width: 100%;
  font-weight: 600;
  flex-shrink: 0;
  color: hsl(var(--foreground));
}
@media (min-width: 640px) {
  .dmca-label {
    width: 10rem;
  }
}

.dmca-value {
  word-break: break-all;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

/* =========================================================
    BUTTONS
    ========================================================= */
.primary-action-button {
  width: 100%;
  font-size: 1.125rem;
  line-height: 1.75rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
}

.secondary-action-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
  margin-top: 1.5rem;
}
@media (min-width: 768px) {
  .secondary-action-grid {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
}

.secondary-action-button {
  justify-content: center;
}

/* =========================================================
    FOOTER
    ========================================================= */
.app-footer {
  width: 100%;
  height: 3rem;
  flex-shrink: 0;
  background-color: hsl(var(--secondary));
  padding-top: 1rem;
}

/* =========================================================
    CUSTOM FORM ELEMENTS
    ========================================================= */
.form-select-trigger {
  font-weight: 600;
  border-radius: 0.75rem;
  height: 2.75rem;
  padding-left: 1rem;
  padding-right: 1rem;
  box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  border-width: 2px;
  background-color: hsl(var(--background));
  border-color: hsl(var(--border)) !important;
  color: hsl(var(--foreground));
}

/* =========================================================
    SAFE AREA UTILITIES
    ========================================================= */
.fixed-header {
  padding-top: max(1rem, var(--sat));
}

.fixed-footer {
  padding-bottom: max(1rem, var(--sab));
}

/* =========================================================
    LANDING PAGE
    ========================================================= */
.landing-tabs-list {
  display: grid;
  width: 100%;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  background-color: transparent;
  padding: 0;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.landing-tab-trigger {
  flex: 1 1 0%;
}

.landing-section-title {
  font-size: 1.25rem;
  line-height: 1.75rem;
  font-weight: 600;
  text-align: center;
  color: hsl(var(--foreground));
}

.landing-section-description {
  text-align: center;
  font-weight: 700;
  color: hsl(var(--muted-foreground));
}

.landing-video-container {
  aspect-ratio: 16 / 9;
  width: 100%;
  border-radius: 0.5rem;
  overflow: hidden;
  border-width: 1px;
  border-color: hsl(var(--border));
  background-color: hsl(var(--muted));
}

/* =========================================================
    APP HEADER
    ========================================================= */
.app-header {
  display: flex;
  align-items: center;
  height: 60px;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  background-color: hsl(var(--secondary));
  border-bottom: 2px solid hsl(var(--border));
}

.app-header-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding-left: 0.125rem;
  padding-right: 0.125rem;
}

.app-header-actions {
  display: flex;
  align-items: center;
}
.app-header-actions > * + * {
  margin-left: 0.75rem;
}

.app-header-menu-button {
  display: flex;
  align-items: center;
  height: 2.5rem;
  padding-left: 0.75rem;
  padding-right: 0.75rem;
  border-radius: 9999px;
}
.app-header-menu-button > * + * {
  margin-left: 0.5rem;
}

.app-dropdown-menu {
  width: 14rem;
  border-width: 2px;
  background-color: hsl(var(--card));
  border-color: hsl(var(--border));
}

.app-dropdown-item {
  display: flex;
  align-items: center;
  cursor: pointer;
  font-weight: 700;
  color: hsl(var(--foreground)) !important;
}

.app-dropdown-item:hover,
.app-dropdown-item:focus {
  background-color: hsl(var(--accent));
  color: hsl(var(--accent-foreground)) !important;
}

/* =========================================================
    POPOVERS
    ========================================================= */
.app-popover {
  width: 20rem;
  padding: 0.5rem;
  border-width: 2px;
  background-color: hsl(var(--card));
  border-color: hsl(var(--border));
  color: hsl(var(--card-foreground));
}

/* =========================================================
    HELP DIALOG
    ========================================================= */
.help-dialog-title {
  font-weight: 600;
  color: hsl(var(--foreground)) !important;
}

.help-dialog-body {
  font-weight: 700 !important;
  color: hsl(var(--muted-foreground)) !important;
}

@media (prefers-contrast: more) {
  .help-dialog-body {
    color: #ffffff !important;
  }
}

/* =========================================================
    FILTER & SORT (GENERIC)
    ========================================================= */
.filter-select-trigger,
.sort-select-trigger {
  width: 100%;
  border-radius: 0.75rem;
  height: 2.75rem;
  padding-left: 1rem;
  padding-right: 1rem;
  font-weight: 700;
  box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  border-width: 2px;
  background-color: hsl(var(--primary));
  border-color: hsl(var(--border));
  color: hsl(var(--primary-foreground));
}
@media (min-width: 640px) {
  .filter-select-trigger,
  .sort-select-trigger {
    width: auto;
  }
}

.filter-select-content,
.sort-select-content {
  background-color: hsl(var(--popover));
  border-color: hsl(var(--border));
  color: hsl(var(--popover-foreground));
}

.filter-select-item,
.sort-select-item {
  font-weight: 700;
  color: hsl(var(--foreground));
}

.filter-select-item:hover,
.sort-select-item:hover {
  background-color: hsl(var(--accent));
  color: hsl(var(--accent-foreground));
}

/* High contrast behavior */
.high-contrast .filter-select-trigger,
.high-contrast .sort-select-trigger {
  background-color: hsl(var(--background));
  border-color: hsl(var(--border));
  color: hsl(var(--foreground));
}

.high-contrast .filter-select-content,
.high-contrast .sort-select-content {
  background-color: hsl(var(--background));
  border-color: hsl(var(--border));
  color: hsl(var(--foreground));
}

.high-contrast .filter-select-item:hover,
.high-contrast .sort-select-item:hover {
  background-color: hsl(var(--foreground));
  color: hsl(var(--background));
}

/* =========================================================
    VIEW TOGGLE (GENERIC)
    ========================================================= */
.view-toggle-container {
  display: flex;
  align-items: center;
  padding: 0.25rem;
  border-radius: 0.75rem;
  border-width: 2px;
  box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  background-color: hsl(var(--muted));
  border-color: hsl(var(--border));
}

.view-toggle-button {
  border-radius: 0.5rem;
  height: 2rem;
  width: 2rem;
  color: hsl(var(--foreground));
}


================================================================================
FILE PATH: packages/theme-core/src/styles/contract.css
================================================================================

:root {
  /* Loud fallbacks: if you see this, app did NOT define required brand tokens */
  --brand-primary: 999 100% 50%;
  --brand-secondary: 999 100% 50%;
  --brand-accent: 999 100% 50%;

  /* Status tokens: OPTIONAL (sane defaults) */
  --status-success: 140 70% 45%;
  --status-warning: 45 90% 50%;
  --status-error: 0 84% 60%;
  --status-info: 221 83% 53%;

  /* Neutrals */
  --neutral-white: 0 0% 100%;
  --neutral-black: 0 0% 0%;
}

/* High contrast must be pure B/W: override brand + status tokens too (prevents bleed) */
.high-contrast {
  --brand-primary: 0 0% 0%;
  --brand-secondary: 0 0% 0%;
  --brand-accent: 0 0% 100%;

  --status-success: 0 0% 0%;
  --status-warning: 0 0% 0%;
  --status-error: 0 0% 0%;
  --status-info: 0 0% 0%;
}



================================================================================
FILE PATH: packages/theme-core/src/styles/hooks.css
================================================================================


/* ===================
    BUTTONS
    =================== */
.btn-destructive {
  background-color: hsl(var(--destructive));
  color: hsl(var(--destructive-foreground));
}
.btn-destructive:hover {
  background-color: hsl(var(--destructive) / 0.9);
}

/* ===================
    MESSAGE BUBBLES
    =================== */
.msg-bubble {
  padding: 0.75rem;
  border-radius: 0.5rem;
}

.msg-bubble--mine {
  background-color: hsl(var(--primary) / 0.10);
}

.msg-bubble--theirs {
  background-color: hsl(var(--muted));
}

/* ===================
    STATUS PILLS
    =================== */
.status-pill {
  font-size: 0.75rem;
  line-height: 1rem;
  font-weight: 700;
  padding-left: 0.5rem;
  padding-right: 0.5rem;
  padding-top: 0.125rem;
  padding-bottom: 0.125rem;
  border-radius: 9999px;
}

/* map to semantic tokens (no blue/yellow/green hardcodes) */
.status-pill--open-user {
  background-color: hsl(var(--info) / 0.15);
  color: hsl(var(--info-foreground));
}

.status-pill--admin-reply {
  background-color: hsl(var(--warning) / 0.20);
  color: hsl(var(--warning-foreground));
}

.status-pill--user-reply {
  background-color: hsl(var(--success) / 0.18);
  color: hsl(var(--success-foreground));
}

.status-pill--closed {
  background-color: hsl(var(--muted));
  color: hsl(var(--muted-foreground));
}

.status-pill--default {
  background-color: hsl(var(--muted));
  color: hsl(var(--muted-foreground));
}

/* ===================
    STATUS ICONS
    =================== */
.status-icon {
  height: 1.25rem;
  width: 1.25rem;
}

.status-icon--success { color: hsl(var(--success)); }
.status-icon--warning { color: hsl(var(--warning)); }
.status-icon--info    { color: hsl(var(--info)); }
.status-icon--error   { color: hsl(var(--destructive)); }

/* ===================
    NOTIFICATIONS
    =================== */
.notify-dot {
  position: absolute;
  top: 0.25rem;
  right: 0.25rem;
  height: 0.5rem;
  width: 0.5rem;
  border-radius: 9999px;
  background-color: hsl(var(--destructive));
}

.notify-empty-icon {
  color: hsl(var(--success));
}

/* ===================
    MEDIA PREVIEW
    =================== */
.media-preview {
  position: relative;
  width: 100%;
  height: 100%;
}

.media-preview--frame {
  width: 100%;
  height: auto;
  max-width: 24rem;
  margin-left: auto;
  margin-right: auto;
}

.media-preview--fullwidth {
  width: 100%;
  height: auto;
}


================================================================================
FILE PATH: packages/theme-core/src/styles/index.css
================================================================================
@import "./contract.css";
@import "./tokens.css";
@import "./base.css";
@import "./hooks.css";
/* components.css is a separate entrypoint: @ttt-productions/theme-core/components.css */

================================================================================
FILE PATH: packages/theme-core/src/styles/tokens.css
================================================================================

:root {
  /* Semantic tokens (default = light) */
  --background: var(--neutral-white);
  --foreground: var(--neutral-black);

  --card: var(--neutral-white);
  --card-foreground: var(--neutral-black);

  --popover: var(--neutral-white);
  --popover-foreground: var(--neutral-black);

  --muted: 0 0% 95%;
  --muted-foreground: 0 0% 25%;

  --accent: var(--brand-accent);
  --accent-foreground: var(--neutral-black);

  --primary: var(--brand-primary);
  --primary-foreground: var(--neutral-white);

  --secondary: var(--brand-secondary);
  --secondary-foreground: var(--neutral-white);

  --destructive: var(--status-error);
  --destructive-foreground: var(--neutral-white);

  /* Extra semantic status colors (used by pills/toasts/etc.) */
  --success: var(--status-success);
  --success-foreground: var(--neutral-white);

  --warning: var(--status-warning);
  --warning-foreground: var(--neutral-black);

  --info: var(--status-info);
  --info-foreground: var(--neutral-white);

  --border: var(--brand-primary);
  --ring: var(--brand-primary);

  --radius: 1rem;
}

.dark {
  /* Dark base (brand tokens are still app-controlled) */
  --background: 240 6% 10%;
  --foreground: 0 0% 100%;

  --card: 240 6% 12%;
  --card-foreground: 0 0% 100%;

  --popover: 240 6% 12%;
  --popover-foreground: 0 0% 100%;

  --muted: 240 4% 20%;
  --muted-foreground: 0 0% 85%;

  --border: 0 0% 100%;
  --ring: 0 0% 100%;

  /* status foregrounds still reasonable in dark */
  --success-foreground: 0 0% 0%;
  --warning-foreground: 0 0% 0%;
  --info-foreground: 0 0% 0%;
}

.high-contrast {
  /* Pure B/W semantic tokens */
  --background: 0 0% 0%;
  --foreground: 0 0% 100%;

  --card: 0 0% 0%;
  --card-foreground: 0 0% 100%;

  --popover: 0 0% 0%;
  --popover-foreground: 0 0% 100%;

  --muted: 0 0% 0%;
  --muted-foreground: 0 0% 100%;

  --accent: 0 0% 0%;
  --accent-foreground: 0 0% 100%;

  --primary: 0 0% 100%;
  --primary-foreground: 0 0% 0%;

  --secondary: 0 0% 100%;
  --secondary-foreground: 0 0% 0%;

  --destructive: 0 0% 100%;
  --destructive-foreground: 0 0% 0%;

  --success: 0 0% 100%;
  --success-foreground: 0 0% 0%;

  --warning: 0 0% 100%;
  --warning-foreground: 0 0% 0%;

  --info: 0 0% 100%;
  --info-foreground: 0 0% 0%;

  --border: 0 0% 100%;
  --ring: 0 0% 100%;
}


================================================================================
FILE PATH: packages/theme-core/src/theme-provider.tsx
================================================================================
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";
import { REQUIRED_TOKENS } from "./required-tokens";

function warnMissingTokens() {
  if (typeof window === "undefined") return;
  const root = document.documentElement;
  const styles = getComputedStyle(root);

  const missing = REQUIRED_TOKENS.filter((t) => styles.getPropertyValue(t).trim() === "");
  const loud = REQUIRED_TOKENS.filter((t) => styles.getPropertyValue(t).includes("999 100% 50%"));

  if (missing.length || loud.length) {
    // eslint-disable-next-line no-console
    console.warn(
      `[theme-core] Missing/invalid required theme tokens.\n` +
        (missing.length ? `Missing: ${missing.join(", ")}\n` : "") +
        (loud.length ? `Still using loud fallbacks: ${loud.join(", ")}\n` : "") +
        `Define these in the consuming app (brand contract)`
    );
  }
}

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  React.useEffect(() => {
    if (process.env.NODE_ENV !== "production") warnMissingTokens();
  }, []);

  return (
    <NextThemesProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      themes={["light", "dark", "high-contrast"]}
    >
      {children}
    </NextThemesProvider>
  );
}


================================================================================
FILE PATH: packages/theme-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "composite": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.test.tsx"]
}


================================================================================
FILE PATH: packages/ui-core/package.json
================================================================================
{
    "name": "@ttt-productions/ui-core",
    "version": "0.2.3",
    "description": "Shared UI components for TTT Productions projects",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/ttt-productions/ttt-packages.git",
        "directory": "packages/ui-core"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": [
        "dist"
    ],
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist *.tsbuildinfo",
        "typecheck": "tsc --noEmit",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "keywords": [
        "react",
        "ui",
        "components",
        "shadcn",
        "ttt"
    ],
    "peerDependencies": {
        "react": ">=19.0.0",
        "react-dom": ">=19.0.0"
    },
    "dependencies": {
        "@radix-ui/react-accordion": "^1.2.12",
        "@radix-ui/react-alert-dialog": "^1.1.15",
        "@radix-ui/react-avatar": "^1.1.11",
        "@radix-ui/react-checkbox": "^1.3.3",
        "@radix-ui/react-dialog": "^1.1.15",
        "@radix-ui/react-dropdown-menu": "^2.1.16",
        "@radix-ui/react-label": "^2.1.8",
        "@radix-ui/react-menubar": "^1.1.16",
        "@radix-ui/react-popover": "^1.1.15",
        "@radix-ui/react-progress": "^1.1.8",
        "@radix-ui/react-radio-group": "^1.3.8",
        "@radix-ui/react-scroll-area": "^1.2.10",
        "@radix-ui/react-select": "^2.2.6",
        "@radix-ui/react-separator": "^1.1.8",
        "@radix-ui/react-slider": "^1.3.6",
        "@radix-ui/react-slot": "^1.2.4",
        "@radix-ui/react-switch": "^1.2.6",
        "@radix-ui/react-tabs": "^1.1.13",
        "@radix-ui/react-toast": "^1.2.15",
        "@radix-ui/react-tooltip": "^1.2.8",
        "class-variance-authority": "^0.7.0",
        "clsx": "^2.1.1",
        "lucide-react": "^0.562.0",
        "react-hook-form": "^7.71.1",
        "tailwind-merge": "^2.5.2"
    },
    "devDependencies": {
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
}


================================================================================
FILE PATH: packages/ui-core/README.md
================================================================================
# TTT Packages

Shared packages for TTT Productions and Q-Sports projects.

## Packages

- `@ttt/ui-core` - Shared UI components (shadcn-based)

## Development

```bash
# Install dependencies
npm install

# Build all packages
npm run build

# Clean build artifacts
npm run clean

# Type check
npm run typecheck
```

## Publishing

Packages are automatically published to npm when you push a version tag:

```bash
# Update package version(s)
cd packages/ui-core
npm version patch  # or minor, major

# Commit and tag
git add .
git commit -m "Release v1.0.1"
git tag v1.0.1
git push origin main --tags
```

## Usage in TTT Productions

```bash
npm install @ttt/ui-core
```

```tsx
import { Button } from '@ttt/ui-core';

export default function MyComponent() {
  return <Button>Click me</Button>;
}
```


================================================================================
FILE PATH: packages/ui-core/src/components/accordion.tsx
================================================================================
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "../lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item ref={ref} className={cn(className)} {...props} />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================
FILE PATH: packages/ui-core/src/components/alert-dialog.tsx
================================================================================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "../lib/utils"
import { buttonVariants } from "./button"

const AlertDialog = AlertDialogPrimitive.Root
const AlertDialogTrigger = AlertDialogPrimitive.Trigger
const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("flex flex-col space-y-2 text-center sm:text-left", className)}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================
FILE PATH: packages/ui-core/src/components/alert.tsx
================================================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }


================================================================================
FILE PATH: packages/ui-core/src/components/avatar.tsx
================================================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "../lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, src, ...props }, ref) => {
  if (!src) return null
  return (
    <AvatarPrimitive.Image
      ref={ref}
      src={src}
      className={cn("aspect-square h-full w-full", className)}
      {...props}
    />
  )
})
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-white text-primary font-semibold",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }


================================================================================
FILE PATH: packages/ui-core/src/components/badge.tsx
================================================================================
"use client"

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        professions:
          "bg-[hsl(var(--card))] border-[hsl(var(--brand-primary))] text-[hsl(var(--brand-primary-deep))] border-2",
      },
    },
    defaultVariants: { variant: "default" },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />
}

export { Badge, badgeVariants }


================================================================================
FILE PATH: packages/ui-core/src/components/button.tsx
================================================================================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-bold ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "button-default bg-primary text-primary-foreground hover:bg-primary/90 border-2 border-[hsl(var(--brand-primary-deep))]",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90 border-2 border-[hsl(var(--brand-primary-deep))]",
        success:
          "bg-green-500 text-primary-foreground hover:bg-green-500/90 border-2 border-[hsl(var(--status-success-border))]",
        outline:
          "border-2 border-border bg-background hover:bg-accent hover:text-accent-foreground text-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80 border-2 border-border",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        inverted:
          "bg-[hsl(var(--inverted-background))] text-[hsl(var(--inverted-foreground))] hover:bg-[hsl(var(--inverted-background))]/90 border-2 border-[hsl(var(--inverted-border))]",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, children, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      >
        {children}
      </Comp>
    )
  }
)

Button.displayName = "Button"

export { Button, buttonVariants }


================================================================================
FILE PATH: packages/ui-core/src/components/card.tsx
================================================================================
"use client"

import * as React from "react"
import { cn } from "../lib/utils"

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn("rounded-lg border-2 card-border bg-card text-card-foreground shadow-sm", className)}
      {...props}
    />
  )
)
Card.displayName = "Card"

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
  )
)
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3
      ref={ref}
      className={cn("text-2xl font-semibold leading-none tracking-tight card-title", className)}
      {...props}
    />
  )
)
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn("card-description", className)} {...props} />
  )
)
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
)
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
  )
)
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


================================================================================
FILE PATH: packages/ui-core/src/components/checkbox.tsx
================================================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "../lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }


================================================================================
FILE PATH: packages/ui-core/src/components/date-picker.tsx
================================================================================
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight, ChevronUp, ChevronDown } from "lucide-react"
import { Button } from "./button"
import { cn } from "../lib/utils"

export interface DatePickerProps {
  selected?: Date
  onSelect?: (date: Date | undefined) => void
  disabled?: (date: Date) => boolean
  disablePast?: boolean
  disableFuture?: boolean
  className?: string
}

const MONTHS = [
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December",
]

const DAYS = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

function DatePicker({
  selected,
  onSelect,
  disabled,
  disablePast = false,
  disableFuture = false,
  className,
}: DatePickerProps) {
  const [viewDate, setViewDate] = React.useState(() => selected || new Date())
  const [showYearPicker, setShowYearPicker] = React.useState(false)

  const today = new Date()
  today.setHours(0, 0, 0, 0)

  const getDaysInMonth = (date: Date) => {
    const year = date.getFullYear()
    const month = date.getMonth()
    return new Date(year, month + 1, 0).getDate()
  }

  const getFirstDayOfMonth = (date: Date) => {
    const year = date.getFullYear()
    const month = date.getMonth()
    return new Date(year, month, 1).getDay()
  }

  const isDateDisabled = (date: Date) => {
    const checkDate = new Date(date)
    checkDate.setHours(0, 0, 0, 0)

    if (disablePast && checkDate < today) return true
    if (disableFuture && checkDate > today) return true
    if (disabled && disabled(checkDate)) return true

    return false
  }

  const isDateSelected = (date: Date) => {
    if (!selected) return false
    const selectedDate = new Date(selected)
    selectedDate.setHours(0, 0, 0, 0)
    const checkDate = new Date(date)
    checkDate.setHours(0, 0, 0, 0)
    return selectedDate.getTime() === checkDate.getTime()
  }

  const isToday = (date: Date) => {
    const checkDate = new Date(date)
    checkDate.setHours(0, 0, 0, 0)
    return checkDate.getTime() === today.getTime()
  }

  const generateCalendarDays = () => {
    const year = viewDate.getFullYear()
    const month = viewDate.getMonth()
    const daysInMonth = getDaysInMonth(viewDate)
    const firstDay = getFirstDayOfMonth(viewDate)

    const days: (Date | null)[] = []

    for (let i = 0; i < firstDay; i++) days.push(null)
    for (let day = 1; day <= daysInMonth; day++) days.push(new Date(year, month, day))

    return days
  }

  const previousMonth = () => setViewDate((prev) => new Date(prev.getFullYear(), prev.getMonth() - 1))
  const nextMonth = () => setViewDate((prev) => new Date(prev.getFullYear(), prev.getMonth() + 1))

  const previousYear = () => setViewDate((prev) => new Date(prev.getFullYear() - 1, prev.getMonth()))
  const nextYear = () => setViewDate((prev) => new Date(prev.getFullYear() + 1, prev.getMonth()))

  const handleDateClick = (date: Date) => {
    if (isDateDisabled(date)) return
    onSelect?.(date)
  }

  const calendarDays = generateCalendarDays()

  return (
    <div className={cn("p-4 bg-card rounded-lg", className)}>
      <div className="flex items-center justify-between mb-4">
        <Button variant="default" size="sm" className="h-8 w-8 p-0" onClick={previousMonth}>
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <div className="flex items-center gap-2">
          <button
            onClick={() => setShowYearPicker(!showYearPicker)}
            className="text-base font-bold hover:opacity-80 transition-opacity text-foreground"
          >
            {MONTHS[viewDate.getMonth()]} {viewDate.getFullYear()}
          </button>

          {showYearPicker && (
            <div className="flex flex-col gap-1">
              <Button variant="ghost" size="sm" className="h-4 w-4 p-0" onClick={nextYear}>
                <ChevronUp className="h-3 w-3" />
              </Button>
              <Button variant="ghost" size="sm" className="h-4 w-4 p-0" onClick={previousYear}>
                <ChevronDown className="h-3 w-3" />
              </Button>
            </div>
          )}
        </div>

        <Button variant="default" size="sm" className="h-8 w-8 p-0" onClick={nextMonth}>
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>

      <div className="grid grid-cols-7 gap-1 mb-2">
        {DAYS.map((day) => (
          <div
            key={day}
            className="text-center text-sm font-bold py-2 text-foreground"
          >
            {day}
          </div>
        ))}
      </div>

      <div className="grid grid-cols-7 gap-1">
        {calendarDays.map((date, index) => {
          if (!date) return <div key={`empty-${index}`} className="h-9" />

          const disabled = isDateDisabled(date)
          const selected = isDateSelected(date)
          const todayDate = isToday(date)

          return (
            <button
              key={date.toISOString()}
              onClick={() => handleDateClick(date)}
              disabled={disabled}
              className={cn(
                "h-9 w-9 rounded-lg text-sm font-semibold transition-all",
                "hover:scale-105 active:scale-95",
                "flex items-center justify-center",
                !disabled && !selected && !todayDate && "text-foreground hover:bg-primary/10",
                todayDate && !selected && "bg-accent text-foreground font-bold ring-2 ring-border",
                selected && "bg-primary text-white font-bold shadow-lg",
                disabled && "opacity-30 cursor-not-allowed hover:scale-100 hover:bg-transparent",
                disabled && "relative"
              )}
            >
              {date.getDate()}
              {disabled && (
                <div className="absolute inset-0 flex items-center justify-center">
                  <div className="w-px h-full bg-current transform rotate-45" />
                </div>
              )}
            </button>
          )
        })}
      </div>

      <div className="mt-4 pt-3 border-t border-border text-xs space-y-1">
        <div className="flex items-center gap-2">
          <div className="h-3 w-3 rounded bg-primary" />
          <span className="text-muted-foreground">Selected</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="h-3 w-3 rounded bg-accent ring-2 ring-border" />
          <span className="text-muted-foreground">Today</span>
        </div>
        {(disablePast || disableFuture || disabled) && (
          <div className="flex items-center gap-2">
            <div className="h-3 w-3 rounded bg-muted opacity-30 relative">
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-px h-full bg-foreground transform rotate-45" />
              </div>
            </div>
            <span className="text-muted-foreground">Unavailable</span>
          </div>
        )}
      </div>
    </div>
  )
}

DatePicker.displayName = "DatePicker"

export { DatePicker }


================================================================================
FILE PATH: packages/ui-core/src/components/dialog.tsx
================================================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "../lib/utils"

const Dialog = DialogPrimitive.Root
const DialogTrigger = DialogPrimitive.Trigger
const DialogPortal = DialogPrimitive.Portal
const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-card p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        "max-h-[90vh] overflow-y-auto",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}


================================================================================
FILE PATH: packages/ui-core/src/components/dropdown-menu.tsx
================================================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "../lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border !bg-card p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 app-dropdown-item",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => (
  <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />
)
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}


================================================================================
FILE PATH: packages/ui-core/src/components/form.tsx
================================================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "../lib/utils"
import { Label } from "./label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) return null

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}


================================================================================
FILE PATH: packages/ui-core/src/components/input.tsx
================================================================================
"use client"

import * as React from "react"
import { cn } from "../lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border-2 border-border bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


================================================================================
FILE PATH: packages/ui-core/src/components/label.tsx
================================================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../lib/utils"

const labelVariants = cva(
  "text-sm font-bold leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


================================================================================
FILE PATH: packages/ui-core/src/components/layout/screen-adaptive-view.tsx
================================================================================
"use client";

import * as React from "react";
import { cn } from "../../lib/utils";
import { useMediaQuery } from "../../hooks/use-media-query";

export type MaxWidthOption =
  | "none"
  | "sm"
  | "md"
  | "lg"
  | "xl"
  | "2xl"
  | "3xl"
  | "4xl"
  | "5xl"
  | "6xl"
  | "7xl"
  | "full";

export interface ScreenAdaptiveViewProps {
  /** Default content (mobile + base) */
  children: React.ReactNode;

  /** Optional content to use on lg and up */
  lgContent?: React.ReactNode;

  /** Optional content to use on xl and up */
  xlContent?: React.ReactNode;

  /** Max width applied at lg (>=1024px) */
  lgMaxWidth?: MaxWidthOption;

  /** Max width applied at xl (>=1280px) */
  xlMaxWidth?: MaxWidthOption;

  /** App-only escape hatch (try to avoid) */
  className?: string;

  /** App-only escape hatch (try to avoid) */
  innerClassName?: string;
}

function widthClass(opt: MaxWidthOption | undefined) {
  switch (opt) {
    case "none":
      return "screen-max-w-none";
    case "sm":
      return "screen-max-w-sm";
    case "md":
      return "screen-max-w-md";
    case "lg":
      return "screen-max-w-lg";
    case "xl":
      return "screen-max-w-xl";
    case "2xl":
      return "screen-max-w-2xl";
    case "3xl":
      return "screen-max-w-3xl";
    case "4xl":
      return "screen-max-w-4xl";
    case "5xl":
      return "screen-max-w-5xl";
    case "6xl":
      return "screen-max-w-6xl";
    case "7xl":
      return "screen-max-w-7xl";
    case "full":
      return "screen-max-w-full";
    default:
      return "screen-max-w-6xl";
  }
}

export function ScreenAdaptiveView({
  children,
  lgContent,
  xlContent,
  lgMaxWidth = "4xl",
  xlMaxWidth = "6xl",
  className,
  innerClassName,
}: ScreenAdaptiveViewProps) {
  const isLg = useMediaQuery("(min-width: 1024px)");
  const isXl = useMediaQuery("(min-width: 1280px)");

  // SSR-safe default: render base children as mobile (no max-width)
  // After hydration, swaps to lg/xl content if provided.
  const contentToShow =
    (isXl && xlContent !== undefined && xlContent !== null)
      ? xlContent
      : (isLg && lgContent !== undefined && lgContent !== null)
        ? lgContent
        : children;

  const sizeClass =
    isXl ? widthClass(xlMaxWidth) : isLg ? widthClass(lgMaxWidth) : "screen-max-w-full";

  return (
    <div className={cn("screen-adaptive-root", className)}>
      <div className={cn("screen-adaptive-inner", sizeClass, innerClassName)}>
        {contentToShow}
      </div>
    </div>
  );
}


================================================================================
FILE PATH: packages/ui-core/src/components/menubar.tsx
================================================================================
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "../lib/utils"

function MenubarMenu({ ...props }: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({ ...props }: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({ ...props }: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({ ...props }: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({ ...props }: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn("flex h-10 items-center space-x-1 rounded-md border bg-background p-1", className)}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & { inset?: boolean }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(({ className, align = "start", alignOffset = -4, sideOffset = 8, ...props }, ref) => (
  <MenubarPrimitive.Portal>
    <MenubarPrimitive.Content
      ref={ref}
      align={align}
      alignOffset={alignOffset}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </MenubarPrimitive.Portal>
))
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & { inset?: boolean }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & { inset?: boolean }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => (
  <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />
)
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}


================================================================================
FILE PATH: packages/ui-core/src/components/popover.tsx
================================================================================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "../lib/utils"

const Popover = PopoverPrimitive.Root
const PopoverTrigger = PopoverPrimitive.Trigger
const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border !bg-card p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


================================================================================
FILE PATH: packages/ui-core/src/components/progress.tsx
================================================================================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"
import { cn } from "../lib/utils"

interface ProgressProps extends React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root> {
  indicatorClassName?: string
}

const Progress = React.forwardRef<React.ElementRef<typeof ProgressPrimitive.Root>, ProgressProps>(
  ({ className, value, indicatorClassName, ...props }, ref) => (
    <ProgressPrimitive.Root
      ref={ref}
      className={cn("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)}
      {...props}
    >
      <ProgressPrimitive.Indicator
        className={cn("h-full w-full flex-1 bg-primary transition-all", indicatorClassName)}
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
)
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }


================================================================================
FILE PATH: packages/ui-core/src/components/radio-group.tsx
================================================================================
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "../lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => (
  <RadioGroupPrimitive.Root className={cn("grid gap-2", className)} {...props} ref={ref} />
))
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => (
  <RadioGroupPrimitive.Item
    ref={ref}
    className={cn(
      "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className
    )}
    {...props}
  >
    <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
      <Circle className="h-2.5 w-2.5 fill-current text-current" />
    </RadioGroupPrimitive.Indicator>
  </RadioGroupPrimitive.Item>
))
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }


================================================================================
FILE PATH: packages/ui-core/src/components/scroll-area.tsx
================================================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "../lib/utils"

interface ScrollAreaProps
  extends React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> {
  viewportRef?: React.Ref<HTMLDivElement>
}

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  ScrollAreaProps
>(({ className, children, viewportRef, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport
      ref={viewportRef}
      className="h-full w-full rounded-[inherit]"
    >
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }


================================================================================
FILE PATH: packages/ui-core/src/components/select.tsx
================================================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../lib/utils"

const Select = SelectPrimitive.Root
const SelectGroup = SelectPrimitive.Group
const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border-2 border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


================================================================================
FILE PATH: packages/ui-core/src/components/separator.tsx
================================================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "../lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(({ className, orientation = "horizontal", decorative = true, ...props }, ref) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn(
      "shrink-0 bg-border",
      orientation === "horizontal" ? "h-[2px] w-full" : "h-full w-[1px]",
      className
    )}
    {...props}
  />
))
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }


================================================================================
FILE PATH: packages/ui-core/src/components/skeleton.tsx
================================================================================
"use client"

import * as React from "react"
import { cn } from "../lib/utils"

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      data-ai-hint="loading placeholder"
      {...props}
    />
  )
}

export { Skeleton }


================================================================================
FILE PATH: packages/ui-core/src/components/slider.tsx
================================================================================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "../lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn("relative flex w-full touch-none select-none items-center", className)}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }


================================================================================
FILE PATH: packages/ui-core/src/components/switch.tsx
================================================================================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "../lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }


================================================================================
FILE PATH: packages/ui-core/src/components/table.tsx
================================================================================
"use client"

import * as React from "react"
import { cn } from "../lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 dark:hover:bg-white/10 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-bold text-label [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-4 align-middle text-label font-bold [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


================================================================================
FILE PATH: packages/ui-core/src/components/tabs.tsx
================================================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "../lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm !font-bold ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      "data-[state=active]:bg-primary data-[state=active]:text-primary-foreground data-[state=active]:shadow-sm data-[state=active]:border-2 data-[state=active]:border-[hsl(var(--brand-primary-deep))]",
      "data-[state=inactive]:border data-[state=inactive]:border-border data-[state=inactive]:bg-background data-[state=inactive]:hover:bg-accent data-[state=inactive]:hover:text-accent-foreground",
      className
    )}
    {...props}
  >
    {children}
  </TabsPrimitive.Trigger>
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }


================================================================================
FILE PATH: packages/ui-core/src/components/textarea.tsx
================================================================================
"use client"

import * as React from "react"
import { cn } from "../lib/utils"

const Textarea = React.forwardRef<HTMLTextAreaElement, React.ComponentProps<"textarea">>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border-2 border-border bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }


================================================================================
FILE PATH: packages/ui-core/src/components/toaster.tsx
================================================================================
"use client";

import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "./toast";
import { useToast } from "../hooks/use-toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider swipeDirection="right" swipeThreshold={32}>
      {toasts.map(({ id, title, description, action, variant, duration, dismissible, ...props }) => (
        <Toast
          key={id}
          variant={(variant === "error" ? "destructive" : variant) ?? "default"}
          duration={duration ?? 5000}
          dismissible={dismissible ?? true}
          {...props}
        >
          <div className="grid gap-1 pr-10">
            {title ? <ToastTitle className="font-bold">{title}</ToastTitle> : null}
            {description ? <ToastDescription className="font-bold">{description}</ToastDescription> : null}
          </div>
          {action}
          {/* Keep exported close if anyone uses it directly */}
          <ToastClose />
        </Toast>
      ))}
      <ToastViewport />
    </ToastProvider>
  );
}


================================================================================
FILE PATH: packages/ui-core/src/components/toast.tsx
================================================================================
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "../lib/utils";

const toastVariants = cva("toast-root", {
  variants: {
    variant: {
      default: "",
      destructive: "data-[variant=destructive]:",
      success: "data-[variant=success]:",
      warning: "data-[variant=warning]:",
      error: "data-[variant=error]:",
    },
  },
  defaultVariants: {
    variant: "default",
  },
});

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport ref={ref} className={cn("toast-viewport", className)} {...props} />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

type ToastRootProps = React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
  VariantProps<typeof toastVariants> & {
    /** ms */
    duration?: number;
    /** show X button */
    dismissible?: boolean;
  };

const Toast = React.forwardRef<React.ElementRef<typeof ToastPrimitives.Root>, ToastRootProps>(
  ({ className, variant, duration = 5000, dismissible = true, style, children, ...props }, ref) => {
    // pass duration to Radix AND to CSS countdown bar
    const mergedStyle: React.CSSProperties = {
      ...(style as React.CSSProperties),
      ["--toast-duration" as any]: `${duration}ms`,
    };

    return (
      <ToastPrimitives.Root
        ref={ref}
        duration={duration}
        data-variant={variant}
        className={cn(toastVariants({ variant }), className)}
        style={mergedStyle}
        {...props}
      >
        {children}

        {/* countdown bar */}
        <div className="toast-progress" />

        {/* dismiss button */}
        {dismissible ? (
          <ToastPrimitives.Close className="toast-dismiss" aria-label="Dismiss toast">
            <X className="h-4 w-4" />
          </ToastPrimitives.Close>
        ) : null}
      </ToastPrimitives.Root>
    );
  }
);
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action ref={ref} className={cn(className)} {...props} />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close ref={ref} className={cn("toast-dismiss", className)} {...props} />
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn(className)} {...props} />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn(className)} {...props} />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

/** Exported types for consumers */
export type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;
export type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};


================================================================================
FILE PATH: packages/ui-core/src/components/tooltip.tsx
================================================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "../lib/utils"

const TooltipProvider = TooltipPrimitive.Provider
const Tooltip = TooltipPrimitive.Root
const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


================================================================================
FILE PATH: packages/ui-core/src/hooks/use-media-query.tsx
================================================================================
"use client";

import * as React from "react";

export function useMediaQuery(query: string) {
  const [matches, setMatches] = React.useState(false);

  React.useEffect(() => {
    if (typeof window === "undefined" || !window.matchMedia) return;

    const mql = window.matchMedia(query);
    const onChange = (e: MediaQueryListEvent) => setMatches(e.matches);

    // set initial
    setMatches(mql.matches);

    // subscribe
    if (mql.addEventListener) mql.addEventListener("change", onChange);
    else mql.addListener(onChange);

    return () => {
      if (mql.removeEventListener) mql.removeEventListener("change", onChange);
      else mql.removeListener(onChange);
    };
  }, [query]);

  return matches;
}


================================================================================
FILE PATH: packages/ui-core/src/hooks/use-toast.tsx
================================================================================
import * as React from "react";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

export type ToastVariant = "default" | "destructive" | "success" | "warning" | "error";

export type ToasterToast = {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: React.ReactNode;
  variant?: ToastVariant;

  /** ms */
  duration?: number;

  /** show X button */
  dismissible?: boolean;
};

type ToastProps = ToasterToast;

type Action =
  | { type: "ADD_TOAST"; toast: ToastProps }
  | { type: "UPDATE_TOAST"; toast: Partial<ToastProps> & { id: string } }
  | { type: "DISMISS_TOAST"; toastId?: string }
  | { type: "REMOVE_TOAST"; toastId?: string };

interface State {
  toasts: ToastProps[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST": {
      return { ...state, toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT) };
    }
    case "UPDATE_TOAST": {
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };
    }
    case "DISMISS_TOAST": {
      const { toastId } = action;

      if (toastId) {
        return { ...state, toasts: state.toasts.map((t) => (t.id === toastId ? { ...t } : t)) };
      }

      return { ...state, toasts: state.toasts.map((t) => ({ ...t })) };
    }
    case "REMOVE_TOAST": {
      const { toastId } = action;
      if (!toastId) return { ...state, toasts: [] };
      return { ...state, toasts: state.toasts.filter((t) => t.id !== toastId) };
    }
    default:
      return state;
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => listener(memoryState));
}

function genId() {
  return Math.random().toString(36).slice(2, 10);
}

function addToRemoveQueue(toastId: string) {
  if (toastTimeouts.has(toastId)) return;

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({ type: "REMOVE_TOAST", toastId });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
}

export function toast(input: Omit<ToastProps, "id">) {
  const id = genId();

  dispatch({
    type: "ADD_TOAST",
    toast: {
      id,
      dismissible: true,
      duration: 5000,
      variant: "default",
      ...input,
    },
  });

  return {
    id,
    dismiss: () => {
      dispatch({ type: "DISMISS_TOAST", toastId: id });
      addToRemoveQueue(id);
    },
    update: (props: Partial<ToastProps>) =>
      dispatch({ type: "UPDATE_TOAST", toast: { ...props, id } }),
  };
}

export function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) listeners.splice(index, 1);
    };
  }, []);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => {
      dispatch({ type: "DISMISS_TOAST", toastId });
      if (toastId) addToRemoveQueue(toastId);
    },
  };
}


================================================================================
FILE PATH: packages/ui-core/src/index.ts
================================================================================
// Export all components
export * from "./components/button";
export * from "./components/card";
export * from "./components/label";
export * from "./components/textarea";
export * from "./components/skeleton";
export * from "./components/dialog";
export * from "./components/popover";
export * from "./components/dropdown-menu";
export * from "./components/menubar";
export * from "./components/alert-dialog";
export * from "./components/alert";
export * from "./components/toast";
export * from "./components/toaster";
export * from "./hooks/use-toast";
export * from "./components/input";
export * from "./components/select";
export * from "./components/tabs";
export * from "./components/tooltip";
export * from "./components/form";
export * from "./components/checkbox";
export * from "./components/switch";
export * from "./components/badge";
export * from "./components/avatar";
export * from "./components/separator";
export * from "./components/accordion";
export * from "./components/radio-group";
export * from "./components/progress";
export * from "./components/slider";
export * from "./components/date-picker";
export * from "./components/scroll-area";
export * from "./components/table";

// Layout
export * from "./components/layout/screen-adaptive-view";

// Hooks
export * from "./hooks/use-media-query";

// Export utilities
export * from "./lib/utils";


================================================================================
FILE PATH: packages/ui-core/src/lib/utils.ts
================================================================================
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * Merge Tailwind CSS classes with proper precedence
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

================================================================================
FILE PATH: packages/ui-core/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "composite": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.test.tsx"]
}


================================================================================
FILE PATH: packages/upload-core/package.json
================================================================================
{
    "name": "@ttt-productions/upload-core",
    "version": "0.0.0",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/ttt-productions/ttt-packages.git",
      "directory": "packages/upload-core"
    },
    "type": "module",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "sideEffects": false,
    "files": ["dist"],
    "exports": {
      ".": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "./react": {
        "types": "./dist/react/index.d.ts",
        "default": "./dist/react/index.js"
      }
    },
    "scripts": {
      "build": "tsc",
      "clean": "rm -rf dist *.tsbuildinfo",
      "typecheck": "tsc --noEmit",
      "prepublishOnly": "npm run clean && npm run build"
    },
    "peerDependencies": {
      "firebase": ">=10.0.0",
      "react": ">=18.0.0"
    },
    "devDependencies": {
      "typescript": "^5.8.3"
    },
    "author": "DJ (TTT Productions)",
    "license": "MIT"
  }
  

================================================================================
FILE PATH: packages/upload-core/src/index.ts
================================================================================
export * from "./types";

export * from "./storage/upload";
export * from "./storage/delete";

export * from "./utils/filename";
export * from "./utils/path";
export * from "./utils/upload-store";


================================================================================
FILE PATH: packages/upload-core/src/react/index.ts
================================================================================
export * from "./use-upload-file";
export * from "./use-upload-controller";


================================================================================
FILE PATH: packages/upload-core/src/react/use-upload-controller.ts
================================================================================
"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import type { StartUploadArgs, UploadController, UploadSessionState } from "../types";
import { startResumableUpload } from "../storage/upload";
import { getUploadSession, subscribeUploadSession } from "../utils/upload-store";

export function useUploadController() {
  const [controller, setController] = useState<UploadController | null>(null);
  const [session, setSession] = useState<UploadSessionState | null>(null);

  useEffect(() => {
    if (!controller) return;
    const id = controller.id;
    setSession(getUploadSession(id) ?? null);
    return subscribeUploadSession(id, (s) => setSession(s));
  }, [controller]);

  const start = useCallback((args: StartUploadArgs) => {
    const c = startResumableUpload(args);
    setController(c);
    return c;
  }, []);

  const api = useMemo(() => {
    return {
      start,
      controller,
      session,
      pause: () => controller?.pause() ?? false,
      resume: () => controller?.resume() ?? false,
      cancel: () => controller?.cancel() ?? false,
    };
  }, [start, controller, session]);

  return api;
}


================================================================================
FILE PATH: packages/upload-core/src/react/use-upload-file.ts
================================================================================
"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import type { UploadFileResumableArgs, UploadFileResumableResult } from "../types";
import { uploadFileResumable } from "../storage/upload";

export function useUploadFile() {
  const [progress, setProgress] = useState<number>(0);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<unknown>(null);

  const mountedRef = useRef(true);

  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  const upload = useCallback(
    async (args: Omit<UploadFileResumableArgs, "onProgress">): Promise<UploadFileResumableResult> => {
      setIsUploading(true);
      setError(null);
      setProgress(0);

      try {
        const res = await uploadFileResumable({
          ...args,
          onProgress: ({ percent }) => {
            if (!mountedRef.current) return;
            setProgress(percent);
          },
        });

        if (!mountedRef.current) return res;

        setProgress(100);
        setIsUploading(false);
        return res;
      } catch (e) {
        if (mountedRef.current) {
          setError(e);
          setIsUploading(false);
        }
        throw e;
      }
    },
    []
  );

  return { upload, progress, isUploading, error };
}


================================================================================
FILE PATH: packages/upload-core/src/storage/delete.ts
================================================================================
import type { DeleteFileArgs } from "../types";
import { deleteObject, ref } from "firebase/storage";

export async function deleteFile(args: DeleteFileArgs): Promise<void> {
  const { storage, path } = args;
  await deleteObject(ref(storage, path));
}


================================================================================
FILE PATH: packages/upload-core/src/storage/upload.ts
================================================================================
import type {
  StartUploadArgs,
  UploadController,
  UploadFileResumableArgs,
  UploadFileResumableResult,
} from "../types";
import { getDownloadURL, ref, uploadBytesResumable } from "firebase/storage";
import { upsertUploadSession } from "../utils/upload-store";

function genId() {
  return `upl_${Math.random().toString(36).slice(2)}_${Date.now().toString(36)}`;
}

export async function uploadFileResumable(
  args: UploadFileResumableArgs
): Promise<UploadFileResumableResult> {
  const { storage, path, file, metadata, onProgress } = args;

  const storageRef = ref(storage, path);

  return await new Promise((resolve, reject) => {
    const task = uploadBytesResumable(storageRef, file, metadata);

    task.on(
      "state_changed",
      (snap) => {
        if (!onProgress) return;
        const total = snap.totalBytes || 0;
        const transferred = snap.bytesTransferred || 0;
        const percent = total > 0 ? (transferred / total) * 100 : 0;
        onProgress({ transferred, total, percent, snapshot: snap });
      },
      (err) => reject(err),
      async () => {
        const downloadURL = await getDownloadURL(task.snapshot.ref);
        resolve({
          downloadURL,
          fullPath: task.snapshot.ref.fullPath,
          contentType: task.snapshot.metadata.contentType ?? null,
          size: task.snapshot.totalBytes ?? (file as any).size ?? 0,
        });
      }
    );
  });
}

export function startResumableUpload(args: StartUploadArgs): UploadController {
  const { storage, path, file, metadata } = args;
  const id = args.id ?? genId();

  const startedAt = Date.now();

  upsertUploadSession({
    id,
    status: "uploading",
    path,
    transferred: 0,
    total: (file as any).size ?? 0,
    percent: 0,
    startedAt,
    updatedAt: startedAt,
  });

  const storageRef = ref(storage, path);
  const task = uploadBytesResumable(storageRef, file, metadata);

  const done = new Promise<UploadFileResumableResult>((resolve, reject) => {
    task.on(
      "state_changed",
      (snap) => {
        const total = snap.totalBytes || 0;
        const transferred = snap.bytesTransferred || 0;
        const percent = total > 0 ? (transferred / total) * 100 : 0;

        const status =
          task.snapshot.state === "paused"
            ? "paused"
            : task.snapshot.state === "running"
              ? "uploading"
              : "uploading";

        upsertUploadSession({
          id,
          status,
          path,
          total,
          transferred,
          percent,
          updatedAt: Date.now(),
        });
      },
      (error) => {
        const isCanceled =
          (error as any)?.code === "storage/canceled" ||
          (error as any)?.name === "FirebaseError" && (error as any)?.code === "storage/canceled";

        upsertUploadSession({
          id,
          status: isCanceled ? "canceled" : "error",
          path,
          error,
          updatedAt: Date.now(),
        });

        reject(error);
      },
      async () => {
        const downloadURL = await getDownloadURL(task.snapshot.ref);
        const result: UploadFileResumableResult = {
          downloadURL,
          fullPath: task.snapshot.ref.fullPath,
          contentType: task.snapshot.metadata.contentType ?? null,
          size: task.snapshot.totalBytes ?? (file as any).size ?? 0,
        };

        upsertUploadSession({
          id,
          status: "success",
          path,
          transferred: task.snapshot.totalBytes || 0,
          total: task.snapshot.totalBytes || 0,
          percent: 100,
          result,
          updatedAt: Date.now(),
        });

        resolve(result);
      }
    );
  });

  return {
    id,
    task,
    pause: () => task.pause(),
    resume: () => task.resume(),
    cancel: () => task.cancel(),
    done,
  };
}


================================================================================
FILE PATH: packages/upload-core/src/types.ts
================================================================================
import type { FirebaseStorage, UploadMetadata, UploadTask, UploadTaskSnapshot } from "firebase/storage";

export type UploadProgressHandler = (p: {
  transferred: number;
  total: number;
  percent: number; // 0..100
  snapshot?: UploadTaskSnapshot;
}) => void;

export interface UploadFileResumableArgs {
  storage: FirebaseStorage;
  path: string;
  file: Blob | File;
  metadata?: UploadMetadata;
  onProgress?: UploadProgressHandler;
}

export interface UploadFileResumableResult {
  downloadURL: string;
  fullPath: string;
  contentType: string | null;
  size: number;
}

export interface DeleteFileArgs {
  storage: FirebaseStorage;
  path: string;
}

export type UploadSessionStatus =
  | "idle"
  | "uploading"
  | "paused"
  | "success"
  | "error"
  | "canceled";

export interface UploadSessionState {
  id: string;
  status: UploadSessionStatus;
  path: string;

  transferred: number;
  total: number;
  percent: number; // 0..100

  startedAt: number;
  updatedAt: number;

  error?: unknown;
  result?: UploadFileResumableResult;
}

export interface UploadController {
  id: string;
  task: UploadTask;

  pause: () => boolean;
  resume: () => boolean;
  cancel: () => boolean;

  /** Resolves on success, rejects on error/cancel. */
  done: Promise<UploadFileResumableResult>;
}

export interface StartUploadArgs extends Omit<UploadFileResumableArgs, "onProgress"> {
  /** Optional stable id for UI tracking. */
  id?: string;
}


================================================================================
FILE PATH: packages/upload-core/src/utils/filename.ts
================================================================================
export function normalizeFilename(name: string): string {
    const trimmed = (name || "").trim();
    if (!trimmed) return "file";
  
    // keep extension if present
    const lastDot = trimmed.lastIndexOf(".");
    const base = lastDot > 0 ? trimmed.slice(0, lastDot) : trimmed;
    const ext = lastDot > 0 ? trimmed.slice(lastDot).toLowerCase() : "";
  
    const safeBase = base
      .toLowerCase()
      .replace(/[^a-z0-9-_ ]/g, "")
      .replace(/\s+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");
  
    return `${safeBase || "file"}${ext}`;
  }
  

================================================================================
FILE PATH: packages/upload-core/src/utils/path.ts
================================================================================
import { normalizeFilename } from "./filename";

export function buildUploadPath(args: {
  basePath: string;
  ownerId?: string;
  contentId?: string;
  filename?: string;
}) {
  const { basePath, ownerId, contentId, filename } = args;

  const parts = [basePath, ownerId, contentId].filter(Boolean) as string[];
  const prefix = parts.join("/").replace(/\/+/g, "/").replace(/\/$/, "");

  const filePart = filename ? normalizeFilename(filename) : "file";
  return `${prefix}/${filePart}`.replace(/\/+/g, "/");
}


================================================================================
FILE PATH: packages/upload-core/src/utils/upload-store.ts
================================================================================
import type { UploadSessionState } from "../types";

type Listener = (s: UploadSessionState) => void;

const sessions = new Map<string, UploadSessionState>();
const listeners = new Map<string, Set<Listener>>();

function now() {
  return Date.now();
}

export function getUploadSession(id: string): UploadSessionState | undefined {
  return sessions.get(id);
}

export function listUploadSessions(): UploadSessionState[] {
  return Array.from(sessions.values()).sort((a, b) => b.updatedAt - a.updatedAt);
}

export function upsertUploadSession(partial: Partial<UploadSessionState> & Pick<UploadSessionState, "id">) {
  const prev = sessions.get(partial.id);
  const next: UploadSessionState = {
    id: partial.id,
    status: partial.status ?? prev?.status ?? "idle",
    path: partial.path ?? prev?.path ?? "",

    transferred: partial.transferred ?? prev?.transferred ?? 0,
    total: partial.total ?? prev?.total ?? 0,
    percent: partial.percent ?? prev?.percent ?? 0,

    startedAt: partial.startedAt ?? prev?.startedAt ?? now(),
    updatedAt: partial.updatedAt ?? now(),

    error: partial.error ?? prev?.error,
    result: partial.result ?? prev?.result,
  };

  sessions.set(partial.id, next);

  const ls = listeners.get(partial.id);
  if (ls) for (const fn of ls) fn(next);
}

export function removeUploadSession(id: string) {
  sessions.delete(id);
  const ls = listeners.get(id);
  if (ls) listeners.delete(id);
}

export function subscribeUploadSession(id: string, fn: Listener): () => void {
  let set = listeners.get(id);
  if (!set) {
    set = new Set();
    listeners.set(id, set);
  }
  set.add(fn);

  const current = sessions.get(id);
  if (current) fn(current);

  return () => {
    const s = listeners.get(id);
    if (!s) return;
    s.delete(fn);
    if (s.size === 0) listeners.delete(id);
  };
}


================================================================================
FILE PATH: packages/upload-core/tsconfig.json
================================================================================
{
    "extends": "../../tsconfig.json",
    "compilerOptions": {
      "outDir": "dist",
      "rootDir": "src",
      "noEmitOnError": true
    },
    "include": ["src"]
  }
  
